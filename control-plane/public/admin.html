<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VeraLux Admin</title>
    <style>
      :root {
        --bg: #070708;
        --panel: rgba(246, 243, 236, 0.06);
        --panel-strong: rgba(246, 243, 236, 0.12);
        --text: #F6F3EC;
        --muted: #a09a8e;
        --primary: #C9A04E;
        --accent: #C9A04E;
        --danger: #c45050;
        --shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
        font-family: "Space Grotesk", "Avenir Next", "Helvetica Neue", sans-serif;
        color: var(--text);
        background: var(--bg);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 18% 22%, rgba(201, 160, 78, 0.14), transparent 28%),
          radial-gradient(circle at 82% 18%, rgba(201, 160, 78, 0.10), transparent 30%),
          radial-gradient(circle at 50% 85%, rgba(201, 160, 78, 0.06), transparent 35%),
          linear-gradient(145deg, #070708 0%, #0d0b08 55%, #0a0908 100%);
      }
      .glow {
        position: fixed;
        inset: 0;
        pointer-events: none;
        filter: blur(80px);
        opacity: 0.3;
        background: radial-gradient(circle at 28% 28%, #C9A04E, transparent 26%),
          radial-gradient(circle at 72% 22%, #C9A04E, transparent 24%);
      }
      header {
        padding: 20px 28px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .logo {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        box-shadow: 0 15px 35px rgba(201, 160, 78, 0.38);
        overflow: hidden;
      }
      .logo img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.02em;
      }
      .tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.1);
        color: var(--primary);
        border: 1px solid rgba(201, 160, 78, 0.25);
      }
      main {
        padding: 0 28px 32px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 16px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(12px);
        position: relative;
        overflow: hidden;
      }
      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(201, 160, 78, 0.08), rgba(201, 160, 78, 0.06));
        opacity: 0.6;
        pointer-events: none;
      }
      .hero {
        grid-column: 1 / -1;
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 16px;
      }
      .hero .headline {
        font-size: 26px;
        line-height: 1.3;
        margin: 0 0 8px;
      }
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      .summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .summary-card {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
      }
      .summary-card h3 {
        margin: 0 0 6px;
        font-size: 14px;
      }
      .summary-card .value {
        font-size: 22px;
        font-weight: 700;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-size: 12px;
        letter-spacing: 0.01em;
      }
      input,
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        margin-bottom: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        font-family: inherit;
      }
      select option {
        background: var(--bg, #070708);
        color: var(--text);
      }
      select option:checked {
        background: var(--primary, #C9A04E);
        color: #fff;
      }
      select optgroup {
        background: rgba(201, 160, 78, 0.08);
        color: var(--primary, #C9A04E);
        font-style: normal;
        font-weight: 600;
        padding: 6px 0;
      }
      input:focus,
      select:focus,
      textarea:focus {
        outline: 1px solid var(--primary);
      }
      button {
        background: linear-gradient(135deg, #C9A04E, #a67e3a);
        color: #070708;
        border: none;
        border-radius: 10px;
        padding: 10px 12px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.01em;
        box-shadow: 0 10px 30px rgba(201, 160, 78, 0.28);
        transition: transform 0.08s ease, box-shadow 0.1s ease;
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text);
        box-shadow: none;
      }
      button.recording {
        background: rgba(196, 80, 80, 0.85);
        color: white;
        animation: pulse-recording 1s ease-in-out infinite;
      }
      @keyframes pulse-recording {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 36px rgba(201, 160, 78, 0.35);
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 700;
      }
      .pill.ok {
        background: rgba(201, 160, 78, 0.2);
        color: #C9A04E;
      }
      .pill.warn {
        background: rgba(201, 160, 78, 0.15);
        color: #d4af61;
      }
      .pill.err {
        background: rgba(180, 60, 60, 0.25);
        color: #e07070;
      }
      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .call {
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding: 10px 0;
      }
      .call:last-child {
        border-bottom: none;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
      }
      .card {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.09);
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 100px;
      }
      .flex-between {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
        align-items: stretch;
      }
      .status-grid .card {
        height: 100%;
      }
      .card .flex-between {
        align-items: flex-start;
        gap: 8px;
      }
      .health-card {
        padding: 14px;
        gap: 10px;
      }
      .health-header {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: center;
      }
      .health-title {
        font-weight: 700;
        font-size: 14px;
      }
      .health-body {
        display: grid;
        gap: 4px;
        margin-top: 6px;
      }
      .health-line {
        font-size: 12px;
        color: var(--muted);
        word-break: break-word;
      }
      .tabs {
        display: flex;
        gap: 8px;
        padding: 0 28px 12px;
        flex-wrap: wrap;
      }
      .tab {
        padding: 10px 14px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.12);
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.08s ease, box-shadow 0.1s ease, background 0.1s ease;
      }
      .tab.active {
        background: linear-gradient(135deg, #C9A04E, #a67e3a);
        color: #070708;
        box-shadow: 0 12px 30px rgba(201, 160, 78, 0.35);
        transform: translateY(-1px);
      }
      .tab-content {
        display: none;
        gap: 16px;
      }
      .tab-content.active {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        gap: 16px;
      }
      .status-bar {
        margin: 0 28px 12px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .status-bar.ok {
        border-color: rgba(201, 160, 78, 0.4);
        background: rgba(201, 160, 78, 0.08);
      }
      .status-bar.err {
        border-color: rgba(180, 60, 60, 0.4);
        background: rgba(180, 60, 60, 0.12);
      }
      .debug-block {
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 10px;
        color: #c5bfb2;
        font-size: 12px;
        overflow: auto;
        max-height: 200px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        z-index: 1000;
      }
      .modal.active {
        display: flex;
      }
      .modal-card {
        background: #0d0b08;
        border: 1px solid rgba(201, 160, 78, 0.3);
        border-radius: 12px;
        padding: 16px;
        width: min(400px, 90vw);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }
      .modal-card h3 {
        margin: 0 0 8px;
      }
      .modal-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="glow"></div>
    <header>
      <div class="brand">
        <div class="logo"><img src="https://veralux.ai/wp-content/uploads/2025/11/eralux-100-x-98-px-1-300x293.png" alt="VeraLux"></div>
        <div>
          <h1>VeraLux Receptionist</h1>
          <div class="muted">Precision control, live insight.</div>
        </div>
      </div>
      <div class="tag">Live • Admin Console</div>
    </header>

    <div class="tabs">
      <button type="button" class="tab active" data-tab="overview">Overview</button>
      <button type="button" class="tab" data-tab="models">Models &amp; Prompts</button>
      <button type="button" class="tab" data-tab="forwarding">Forwarding &amp; Products</button>
      <button type="button" class="tab" data-tab="analytics">Analytics</button>
      <button type="button" class="tab" data-tab="calls">Calls</button>
      <button type="button" class="tab" data-tab="audit">Audit Logs</button>
      <button type="button" class="tab" data-tab="billing">Billing</button>
      <button type="button" class="tab" data-tab="workflows">Workflows</button>
      <button type="button" class="tab" data-tab="settings">Settings</button>
      <button type="button" class="tab" id="refresh-all" style="margin-left: auto">Refresh All</button>
    </div>
    <div class="status-bar" id="tenant-bar" style="flex-wrap: wrap; gap: 8px">
      <div class="row" style="gap: 6px">
        <div class="small">Business</div>
        <select id="tenant-select" title="Each business has its own receptionist, prompts, and phone numbers"></select>
        <button type="button" class="secondary" id="tenant-reload">Refresh list</button>
      </div>
      <div class="row" style="gap: 6px; flex-wrap: wrap">
        <input id="tenant-new-id" type="text" placeholder="e.g. acme-corp or main-office" style="min-width: 160px" title="Short ID for this business (used in config and URLs)" />
        <input
          id="tenant-new-numbers"
          type="text"
          placeholder="Phone numbers that ring this receptionist (comma-separated, e.g. +15551234567)"
          style="min-width: 260px"
        />
        <button type="button" id="tenant-create">Save business</button>
      </div>
      <div id="tenant-meta" class="small" style="width: 100%"></div>
    </div>
    <div id="status-bar" class="status-bar">Ready</div>

    <main>
      <div class="tab-content active" data-tab="overview">
        <section class="panel hero">
          <div>
            <p class="headline">Command your receptionist brain with real-time controls, health, and insight.</p>
            <div class="muted">
              Switch models, watch health signals, and track caller intent without leaving this pane.
            </div>
            <div class="summary" style="margin-top: 14px">
              <div class="summary-card">
                <h3>Provider</h3>
                <div id="summary-provider" class="value">—</div>
                <div id="summary-model" class="small"></div>
              </div>
              <div class="summary-card">
                <h3>Calls</h3>
                <div id="summary-calls" class="value">0</div>
                <div class="small">Total handled</div>
              </div>
              <div class="summary-card">
                <h3>Messages</h3>
                <div id="summary-messages" class="value">0</div>
                <div class="small">Caller utterances</div>
              </div>
            </div>
          </div>
          <div class="panel" style="background: rgba(255, 255, 255, 0.06)">
            <h2>Pipeline Health</h2>
            <div id="health-status" class="status-grid" style="margin-top: 10px"></div>
            <div class="row" style="margin-top: 8px">
              <button type="button" class="secondary" id="refresh-health">Refresh</button>
            </div>
          </div>
        </section>
        <section class="panel">
          <div class="flex-between" style="margin-bottom: 8px">
            <h2>Diagnostics</h2>
            <button type="button" class="secondary" id="refresh-debug">Refresh</button>
          </div>
          <div class="small">Config (safe)</div>
          <div id="debug-config" class="debug-block">—</div>
          <div class="small" style="margin-top: 8px">Health (raw)</div>
          <div id="debug-health" class="debug-block">—</div>
        </section>
      </div>

      <div class="tab-content" data-tab="models">
        <section class="panel">
          <h2>Model Selection</h2>
          <form id="config-form">
            <label for="provider">Provider</label>
            <select id="provider" name="provider">
              <option value="openai">OpenAI (ChatGPT)</option>
              <option value="local">Local LLM</option>
            </select>

            <div id="openai-fields">
              <label for="openaiModel">Model</label>
              <input id="openaiModel" name="openaiModel" type="text" placeholder="llama3.2:3b" />

              <label for="openaiApiKey">API key (kept server-side, never shown)</label>
              <input id="openaiApiKey" name="openaiApiKey" type="password" autocomplete="off" placeholder="sk-..." />
              <div class="small" id="api-key-status">API key not set</div>
            </div>

            <div id="local-fields" style="display:none;">
              <label for="localUrl">Local LLM URL</label>
              <input id="localUrl" name="localUrl" type="text" placeholder="http://127.0.0.1:8080/completion" />
            </div>

            <div class="row" style="margin-top: 6px">
              <button type="submit">Apply</button>
              <button type="button" class="secondary" id="refresh-config">Refresh</button>
            </div>
            <div id="config-status" class="small" style="margin-top: 6px"></div>
          </form>
        </section>

        <section class="panel">
          <h2>Prompt Controls</h2>
          <form id="prompt-form">
            <label for="greetingText">Greeting message (what callers hear first)</label>
            <textarea id="greetingText" name="greetingText" rows="2" placeholder="e.g. Hi! Thanks for calling King-Sod Lawn Care. How can I help you today?"></textarea>

            <label for="systemPreamble">System preamble (role, scope, goals, stages)</label>
            <textarea id="systemPreamble" name="systemPreamble" rows="4"></textarea>

            <label for="policyPrompt">Policy prompt (hard guardrails / never-do list)</label>
            <textarea id="policyPrompt" name="policyPrompt" rows="4"></textarea>

            <label for="voicePrompt">Voice prompt (phone tone)</label>
            <textarea id="voicePrompt" name="voicePrompt" rows="3"></textarea>

            <label for="schemaHint">Schema hint</label>
            <textarea id="schemaHint" name="schemaHint" rows="6"></textarea>

            <div class="row" style="margin-top: 6px">
              <button type="submit">Save Prompts</button>
              <button type="button" class="secondary" id="refresh-prompts">Reset View</button>
            </div>
            <div id="prompt-status" class="small" style="margin-top: 6px"></div>
          </form>
        </section>

        <!-- Voice & TTS Panel (Kokoro / XTTS) -->
        <section class="panel">
          <h2>Voice &amp; TTS (Kokoro / XTTS)</h2>
          <form id="tts-form">
            <label for="ttsMode">TTS Mode</label>
            <select id="ttsMode" name="ttsMode">
              <option value="coqui_xtts" selected>Coqui XTTS (Voice Cloning)</option>
              <option value="kokoro_http">Kokoro HTTP</option>
            </select>
            <div class="small" style="margin-top: -8px; margin-bottom: 12px">
              <strong>Coqui XTTS:</strong> Advanced voice cloning with hot-swap support (recommended). <strong>Kokoro:</strong> Fast, lightweight TTS.
            </div>

            <label for="ttsUrl">TTS server URL</label>
            <input id="ttsUrl" name="xttsUrl" type="url" placeholder="e.g. http://127.0.0.1:8020/tts or https://your-xtts.example.com/tts" style="width: 100%; max-width: 420px;" />

            <label for="ttsVoiceId">Preset Voice ID</label>
            <input id="ttsVoiceId" name="voiceId" type="text" placeholder="e.g. en_sample (XTTS default)" />

            <label for="ttsLanguage">Language code</label>
            <input id="ttsLanguage" name="language" type="text" placeholder="e.g. en (English), es (Spanish), fr (French)" />
            <div class="small" style="margin-top: -8px; margin-bottom: 12px">
              ISO 639-1 language codes: <code>en</code> (English), <code>es</code> (Spanish), <code>fr</code> (French), <code>de</code> (German), etc.
            </div>

            <!-- Voice Cloning Section (XTTS only) -->
            <div id="voice-cloning-section" style="display: block; margin-top: 16px; padding: 16px; border-radius: 12px; background: rgba(201, 160, 78, 0.06); border: 1px solid rgba(201, 160, 78, 0.2);">
              <h3 style="margin: 0 0 12px; font-size: 15px; color: var(--primary);">Voice Cloning (XTTS)</h3>
              
              <label for="defaultVoiceMode">Default Voice Mode</label>
              <select id="defaultVoiceMode" name="defaultVoiceMode">
                <option value="preset">Preset Voice (built-in)</option>
                <option value="cloned">Cloned Voice (custom)</option>
              </select>
              <div class="small" style="margin-top: -8px; margin-bottom: 12px">
                Choose which voice to use at the start of calls. Can be hot-swapped during active calls.
              </div>

              <label>Reference Audio for Voice Cloning</label>
              <div class="small" style="margin-bottom: 12px">
                Record 3-15 seconds of clear speech with no background noise. Speak naturally in the tone you want the AI to use.
              </div>
              
              <!-- Audio Recording Controls -->
              <div id="audio-recorder" style="margin-bottom: 16px; padding: 12px; border-radius: 8px; background: rgba(0,0,0,0.2);">
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px;">
                  <button type="button" id="record-btn" class="secondary" style="min-width: 100px;">
                    <span id="record-btn-text">Record</span>
                  </button>
                  <span id="recording-status" style="font-size: 13px; color: var(--muted);"></span>
                  <span id="recording-timer" style="font-size: 13px; font-family: monospace; color: var(--primary);"></span>
                </div>
                
                <!-- Audio Preview -->
                <div id="audio-preview-container" style="display: none; margin-bottom: 12px;">
                  <audio id="audio-preview" controls style="width: 100%; height: 40px;"></audio>
                  <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button type="button" id="use-recording-btn" class="secondary" style="flex: 1;">Use This Recording</button>
                    <button type="button" id="discard-recording-btn" class="secondary" style="flex: 1; background: rgba(180,60,60,0.25);">Discard</button>
                  </div>
                </div>
                
                <!-- Upload Status -->
                <div id="upload-status" style="display: none; font-size: 13px; padding: 8px; border-radius: 6px; background: rgba(201, 160, 78, 0.1);"></div>
              </div>
              
              <label for="clonedVoiceUrl">Reference Audio URL (WAV)</label>
              <input id="clonedVoiceUrl" name="clonedVoiceUrl" type="url" placeholder="Auto-filled after recording, or paste URL manually" />
              <div class="small" style="margin-top: -8px; margin-bottom: 12px">
                This URL is auto-filled when you record and save audio above, or you can paste a URL to an existing WAV file.
              </div>

              <label for="clonedVoiceLabel">Voice Label (optional)</label>
              <input id="clonedVoiceLabel" name="clonedVoiceLabel" type="text" placeholder="e.g. Sarah's Voice, Business Owner" />
              <div class="small" style="margin-top: -8px; margin-bottom: 12px">
                A friendly name for this cloned voice profile.
              </div>

              <div id="voice-cloning-warning" style="display: none; padding: 10px; border-radius: 8px; background: rgba(201, 160, 78, 0.15); border: 1px solid rgba(201, 160, 78, 0.3); margin-bottom: 12px;">
                <span class="small" style="color: var(--accent);">⚠️ Cloned voice mode requires a reference audio URL to be set.</span>
              </div>
            </div>

            <label for="ttsPreset" style="margin-top: 12px">Voice preset</label>
            <select id="ttsPreset" name="preset">
              <option value="neutral">Neutral (default)</option>
              <option value="warm">Warm</option>
              <option value="energetic">Energetic</option>
              <option value="calm">Calm</option>
            </select>

            <label for="ttsRate">
              Speed (rate)
              <span id="ttsRateValue" class="small" style="float: right">0.95</span>
            </label>
            <input id="ttsRate" name="rate" type="range" min="0.80" max="1.20" step="0.01" value="0.95" />
            <div class="small" style="margin-top: -8px; margin-bottom: 12px">1.0 = normal; lower = slower, higher = faster. Works with Kokoro and XTTS.</div>

            <div class="row" style="margin-top: 6px">
              <button type="submit">Save Voice Settings</button>
            </div>
            <div id="tts-status" class="small" style="margin-top: 6px">TTS config saved here. Preview runs in the voice runtime.</div>
          </form>
        </section>

        <!-- Active Call Voice Control (XTTS only) -->
        <section class="panel" id="active-call-voice-panel" style="display: block;">
          <h2>Active Call Voice Control</h2>
          <p class="small muted">Hot-swap voice mode during an active call. Only available when using XTTS mode.</p>
          
          <div class="row" style="gap: 8px; flex-wrap: wrap; margin: 12px 0">
            <input id="call-control-id" type="text" placeholder="Call Control ID" style="min-width: 240px" />
            <button type="button" id="get-call-voice" class="secondary">Get Voice Mode</button>
          </div>

          <div id="call-voice-info" style="display: none; margin: 12px 0; padding: 14px; border-radius: 10px; background: rgba(255, 255, 255, 0.04); border: 1px solid var(--border);">
            <div class="row" style="gap: 16px; flex-wrap: wrap;">
              <div>
                <div class="small">Current Mode</div>
                <div id="call-voice-mode" class="value" style="font-size: 16px; font-weight: 600;">—</div>
              </div>
              <div>
                <div class="small">Cloning Available</div>
                <div id="call-voice-cloning-available" style="font-size: 14px;">—</div>
              </div>
              <div>
                <div class="small">Cloned Voice Label</div>
                <div id="call-voice-label" style="font-size: 14px;">—</div>
              </div>
            </div>
          </div>

          <div class="row" style="gap: 8px; flex-wrap: wrap; margin: 12px 0">
            <select id="set-call-voice-mode" style="min-width: 160px;">
              <option value="preset">Preset Voice</option>
              <option value="cloned">Cloned Voice</option>
            </select>
            <input id="set-call-voice-url" type="url" placeholder="One-time override URL (optional)" style="min-width: 240px" />
            <button type="button" id="set-call-voice">Set Voice Mode</button>
          </div>

          <div id="call-voice-status" class="small" style="margin-top: 6px; min-height: 16px;"></div>
        </section>
      </div>

      <div class="tab-content" data-tab="forwarding">
        <section class="panel">
          <h2>Call Forwarding</h2>
          <p class="small muted">Add the people the receptionist can forward calls to. Include a role and brief description so the AI knows when to route each call.</p>
          <div class="row" style="gap: 8px; flex-wrap: wrap; margin: 10px 0">
            <input id="fp-name" type="text" placeholder="Name" style="min-width: 120px" />
            <input id="fp-number" type="text" placeholder="Number (e.g. +15551234567)" style="min-width: 140px" />
            <input id="fp-role" type="text" placeholder="Role (e.g. Owner)" style="min-width: 120px" />
            <input id="fp-desc" type="text" placeholder="Brief description (e.g. Handles pricing &amp; estimates)" style="min-width: 200px" />
            <button type="button" id="fp-add">Add profile</button>
          </div>
          <ul id="forwarding-profiles-list" style="list-style: none; padding: 0; margin: 8px 0"></ul>
          <button type="button" class="secondary" id="fp-save">Save forwarding profiles</button>
          <div id="fp-status" class="small" style="margin-top: 6px; min-height: 16px"></div>
        </section>
        <section class="panel">
          <h2>Services & products</h2>
          <p class="small muted">Services, products, and prices the receptionist can reference. Kept short for voice.</p>
          <div class="row" style="gap: 8px; flex-wrap: wrap; margin: 10px 0">
            <select id="price-type" style="min-width: 100px">
              <option value="service">Service</option>
              <option value="product">Product</option>
            </select>
            <input id="price-name" type="text" placeholder="Name" style="min-width: 120px" />
            <input id="price-amount" type="text" placeholder="Price (e.g. $50)" style="min-width: 80px" />
            <input id="price-desc" type="text" placeholder="Short description" style="min-width: 140px" />
            <button type="button" id="price-add">Add item</button>
          </div>
          <ul id="pricing-items-list" style="list-style: none; padding: 0; margin: 8px 0"></ul>
          <label for="pricing-notes" class="small">Notes (optional, e.g. &quot;Rates may vary&quot;)</label>
          <textarea id="pricing-notes" rows="2" style="width: 100%; margin-top: 4px; resize: vertical"></textarea>
          <button type="button" class="secondary" id="price-save" style="margin-top: 8px">Save pricing</button>
          <div id="price-status" class="small" style="margin-top: 6px; min-height: 16px"></div>
        </section>
      </div>

      <div class="tab-content" data-tab="analytics">
        <section class="panel">
          <div class="flex-between">
            <h2>Analytics</h2>
            <button type="button" class="secondary" id="refresh-analytics">Refresh</button>
          </div>
          <div id="analytics-summary" class="card" style="margin-top: 8px"></div>
          <div class="list-title">Top questions</div>
          <ul id="top-questions" style="margin-top: 8px"></ul>
        </section>
      </div>

      <div class="tab-content" data-tab="calls">
        <section class="panel">
          <div class="flex-between">
            <h2>Chat History</h2>
            <button type="button" class="secondary" id="refresh-calls">Refresh</button>
          </div>
          <div id="calls" class="call-grid" style="margin-top: 10px"></div>
        </section>
      </div>

      <div class="tab-content" data-tab="audit">
        <section class="panel">
          <div class="flex-between">
            <h2>Audit Logs</h2>
            <button type="button" class="secondary" id="refresh-audit">Refresh</button>
          </div>
          <div id="audit-logs" class="debug-block" style="margin-top: 8px; max-height: 320px"></div>
        </section>
        <section class="panel">
          <div class="flex-between">
            <h2>Admin Access</h2>
            <button type="button" class="secondary" id="refresh-keys">Refresh</button>
          </div>
          <div class="row" style="gap: 8px; flex-wrap: wrap; margin-bottom: 8px">
            <input id="admin-key-name" type="text" placeholder="Key name (e.g. OpsUser)" style="min-width: 180px" />
            <select id="admin-key-role">
              <option value="admin">Admin</option>
              <option value="viewer">Viewer</option>
            </select>
            <button type="button" id="create-admin-key">Create Key</button>
          </div>
          <div id="admin-key-token" class="small" style="color: #C9A04E; min-height: 16px"></div>
          <div class="list-title" style="margin-top: 6px">Existing keys</div>
          <div id="admin-keys" class="debug-block" style="max-height: 260px; overflow: auto"></div>
        </section>

        <section class="panel">
          <h2>Owner Passcode</h2>
          <p class="small" style="margin: 0 0 12px;">Set or reset the passcode that business owners use to log in to the Owner Panel and Portal. This is separate from the admin API key.</p>
          <div class="row" style="gap: 8px; flex-wrap: wrap; margin-bottom: 8px; align-items: flex-end;">
            <div style="flex: 1; min-width: 160px;">
              <label for="passcode-tenant">Tenant</label>
              <input id="passcode-tenant" type="text" placeholder="e.g. King-Sod" style="margin-bottom: 0;" />
            </div>
            <div style="flex: 1; min-width: 160px;">
              <label for="passcode-value">New passcode</label>
              <input id="passcode-value" type="text" placeholder="Min 4 characters" style="margin-bottom: 0;" />
            </div>
            <button type="button" id="passcode-save">Set passcode</button>
          </div>
          <div id="passcode-status" class="small" style="min-height: 16px;"></div>
          <div class="small" style="margin-top: 8px; color: rgba(255,255,255,0.5);">
            Owners sign in at <code>/owner.html</code> or <code>/portal.html</code> using their phone number + this passcode.
          </div>
        </section>
      </div>

      <div class="tab-content" data-tab="billing">
        <section class="panel">
          <h2>Subscription & billing</h2>
          <div id="stripe-status-bar" style="padding:10px; border-radius:8px; margin-bottom:12px; font-size:13px;"></div>

          <!-- Admin toggle — always visible -->
          <div style="display:flex; align-items:center; gap:10px; margin:12px 0; padding:12px; border-radius:10px; background:rgba(201,160,78,0.08); border:1px solid rgba(201,160,78,0.2);">
            <label for="sub-show-portal" style="margin:0; cursor:pointer; display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="sub-show-portal" checked style="width:18px;height:18px;accent-color:#C9A04E;cursor:pointer;" />
              <span>Show billing section to business owner</span>
            </label>
            <span class="small muted">(When off, the owner won't see billing info in their portal)</span>
          </div>

          <!-- Current subscription summary -->
          <div id="sub-summary" style="display:none; margin:12px 0; padding:14px; border-radius:10px; background:rgba(246,243,236,0.04); border:1px solid rgba(246,243,236,0.08);">
            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;">
              <div class="small">Plan: <strong id="sub-summary-plan">—</strong></div>
              <div class="small">Status: <strong id="sub-summary-status">—</strong></div>
              <div class="small">Price: <strong id="sub-summary-price">—</strong></div>
              <div class="small">Frequency: <strong id="sub-summary-freq">—</strong></div>
              <div class="small">Next billing: <strong id="sub-summary-next">—</strong></div>
              <div class="small">Payment: <strong id="sub-summary-card">—</strong></div>
            </div>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button type="button" id="sub-remove" style="background:rgba(196,80,80,0.15); color:#e07070; border:1px solid rgba(196,80,80,0.3); padding:5px 14px; border-radius:8px; font-size:13px; cursor:pointer;">Remove subscription</button>
            </div>
          </div>
        </section>

        <!-- Stripe section — shown when Stripe is connected -->
        <section class="panel" id="stripe-section" style="display:none;">
          <h2>Stripe controls</h2>

          <div id="stripe-configured" style="display:none;">
            <h3>Plans</h3>
            <p class="small muted">Create subscription plans in Stripe. Each plan gets a Stripe Product + Price.</p>
            <div style="display:grid; grid-template-columns:1fr auto auto auto; gap:8px; align-items:end; margin:8px 0;">
              <div>
                <label for="stripe-plan-name" class="small">Plan name</label>
                <input id="stripe-plan-name" type="text" placeholder="e.g. Pro" />
              </div>
              <div>
                <label for="stripe-plan-price" class="small">Price ($)</label>
                <input id="stripe-plan-price" type="number" min="0" step="0.01" placeholder="49.00" style="width:110px;" />
              </div>
              <div>
                <label for="stripe-plan-interval" class="small">Interval</label>
                <select id="stripe-plan-interval" style="width:130px;">
                  <option value="month">Monthly</option>
                  <option value="quarter">Quarterly</option>
                  <option value="year">Yearly</option>
                  <option value="one_time">One-time</option>
                </select>
              </div>
              <div>
                <label class="small" style="visibility:hidden;">Action</label>
                <button type="button" id="stripe-create-plan" style="margin:0;">Create plan</button>
              </div>
            </div>
            <ul id="stripe-plans-list" style="list-style:none; padding:0; margin:8px 0;"></ul>

            <h3 style="margin-top:14px;">Assign plan to this business</h3>
            <p class="small muted">Select a plan and click "Assign plan" to save it to this tenant's subscription. Or generate a Stripe Checkout link for the owner to pay.</p>
            <div class="row" style="gap:8px; flex-wrap:wrap; margin:8px 0;">
              <select id="stripe-assign-plan" style="min-width:180px;"></select>
              <button type="button" id="stripe-assign-save">Assign plan</button>
              <button type="button" class="secondary" id="stripe-send-checkout">Checkout link</button>
              <button type="button" class="secondary" id="stripe-open-portal">Customer portal</button>
              <button type="button" class="secondary" id="stripe-sync">Sync from Stripe</button>
            </div>
            <div id="stripe-checkout-url" style="display:none; margin-top:8px; padding:10px; border-radius:8px; background:rgba(201,160,78,0.08); border:1px solid rgba(201,160,78,0.2); word-break:break-all; font-size:13px;"></div>
            <div id="stripe-action-status" class="small" style="margin-top:6px; min-height:16px;"></div>

            <div style="margin-top:14px; padding:10px; border-radius:8px; background:rgba(246,243,236,0.04); border:1px solid rgba(246,243,236,0.08);">
              <div class="small muted">Stripe IDs for this tenant</div>
              <div class="small" style="margin-top:4px;">
                Customer: <code id="stripe-cust-id">—</code> &nbsp;
                Subscription: <code id="stripe-sub-id">—</code> &nbsp;
                Price: <code id="stripe-price-id">—</code>
              </div>
            </div>
          </div>
        </section>

        <!-- Manual fallback — shown when Stripe is NOT connected -->
        <section class="panel" id="manual-billing-section">
          <h2>Manual subscription setup</h2>
          <p class="small muted">Manage subscription details manually (no payment processing).</p>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div>
              <label for="sub-plan">Plan name</label>
              <input id="sub-plan" type="text" placeholder="e.g. Starter, Pro, Enterprise" />
            </div>
            <div>
              <label for="sub-status">Status</label>
              <select id="sub-status">
                <option value="trial">Trial</option>
                <option value="active">Active</option>
                <option value="past_due">Past due</option>
                <option value="paused">Paused</option>
                <option value="cancelled">Cancelled</option>
              </select>
            </div>
            <div>
              <label for="sub-price">Price ($)</label>
              <input id="sub-price" type="number" min="0" step="0.01" placeholder="49.00" />
            </div>
            <div>
              <label for="sub-currency">Currency</label>
              <select id="sub-currency">
                <option value="usd">USD ($)</option>
                <option value="eur">EUR (&euro;)</option>
                <option value="gbp">GBP (&pound;)</option>
                <option value="cad">CAD (C$)</option>
              </select>
            </div>
            <div>
              <label for="sub-frequency">Billing frequency</label>
              <select id="sub-frequency">
                <option value="monthly">Monthly</option>
                <option value="quarterly">Quarterly</option>
                <option value="yearly">Yearly</option>
                <option value="one_time">One-time</option>
              </select>
            </div>
            <div>
              <label for="sub-next-billing">Next billing date</label>
              <input id="sub-next-billing" type="date" />
            </div>
          </div>

          <h3 style="margin-top:16px;">Payment method on file</h3>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div>
              <label for="sub-card-brand">Card brand</label>
              <select id="sub-card-brand">
                <option value="">None</option>
                <option value="visa">Visa</option>
                <option value="mastercard">Mastercard</option>
                <option value="amex">Amex</option>
                <option value="discover">Discover</option>
                <option value="other">Other</option>
              </select>
            </div>
            <div>
              <label for="sub-card-last4">Last 4 digits</label>
              <input id="sub-card-last4" type="text" maxlength="4" placeholder="4242" />
            </div>
          </div>

          <div style="margin-top:12px;">
            <label for="sub-trial-ends">Trial ends</label>
            <input id="sub-trial-ends" type="date" style="max-width:220px;" />
          </div>

          <h3 style="margin-top:16px;">Admin notes</h3>
          <textarea id="sub-notes" rows="2" placeholder="Internal notes (not shown to owner). e.g. Comp'd for beta, Invoice #1234"></textarea>

          <div class="row" style="margin-top:10px; gap:8px;">
            <button type="button" id="sub-save">Save subscription</button>
            <button type="button" class="secondary" id="sub-refresh">Refresh</button>
          </div>
          <div id="sub-status-msg" class="small" style="margin-top:6px; min-height:16px;"></div>
        </section>

        <!-- Admin notes — always visible when Stripe is active -->
        <section class="panel" id="stripe-admin-extras" style="display:none;">
          <h3>Admin notes</h3>
          <textarea id="sub-notes-stripe" rows="2" placeholder="Internal notes (not shown to owner). e.g. Comp'd for beta, Invoice #1234"></textarea>
          <div class="row" style="margin-top:8px; gap:8px;">
            <button type="button" id="sub-save-stripe">Save settings</button>
            <button type="button" class="secondary" id="sub-refresh-stripe">Refresh</button>
          </div>
          <div id="sub-status-msg-stripe" class="small" style="margin-top:6px; min-height:16px;"></div>
        </section>
      </div>

      <div class="tab-content" data-tab="settings">
        <section class="panel">
          <h2>Cloudflare Tunnel</h2>
          <p class="small" style="margin: 0 0 12px">Expose this instance to the internet securely via Cloudflare Tunnel.</p>

          <!-- Live status -->
          <div id="cf-status-card" style="display:flex;align-items:center;gap:12px;padding:12px 16px;border-radius:12px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);margin-bottom:16px;">
            <div id="cf-status-dot" style="width:12px;height:12px;border-radius:50%;background:#666;flex-shrink:0;"></div>
            <div style="flex:1;">
              <div id="cf-status-text" style="font-weight:600;">Checking…</div>
              <div id="cf-status-detail" class="small" style="margin-top:2px;"></div>
            </div>
            <div style="display:flex;gap:6px;">
              <button type="button" id="cf-start-btn" class="secondary" style="padding:6px 14px;font-size:12px;">Start</button>
              <button type="button" id="cf-stop-btn" class="secondary" style="padding:6px 14px;font-size:12px;">Stop</button>
              <button type="button" id="cf-restart-btn" class="secondary" style="padding:6px 14px;font-size:12px;">Restart</button>
              <button type="button" id="cf-refresh-status" class="secondary" style="padding:6px 14px;font-size:12px;">Refresh</button>
            </div>
          </div>
          <div id="cf-action-status" class="small" style="margin-bottom:12px;min-height:16px;"></div>

          <!-- Token config -->
          <div class="row" style="gap: 8px; align-items: flex-end">
            <div style="flex: 1">
              <label for="cf-tunnel-token">Tunnel Token</label>
              <input id="cf-tunnel-token" type="password" placeholder="Paste your Cloudflare Tunnel token" style="margin-bottom: 0" />
            </div>
            <button type="button" id="cf-toggle-visibility" class="secondary" style="min-width: 70px">Show</button>
            <button type="button" id="cf-save-token">Save</button>
          </div>
          <div id="cf-token-status" class="small" style="margin-top: 8px; min-height: 16px"></div>
        </section>

        <!-- Capacity & Concurrency -->
        <section class="panel">
          <h2>Capacity &amp; Concurrency</h2>
          <p class="small" style="margin: 0 0 16px;">Control how many calls the system can handle simultaneously. Changes take effect immediately — no restart required.</p>

          <!-- Live status -->
          <div id="cap-live-status" style="display:flex;gap:16px;margin-bottom:20px;flex-wrap:wrap;">
            <div style="flex:1;min-width:140px;padding:12px 16px;border-radius:12px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);">
              <div class="small" style="margin-bottom:4px;">Global active calls</div>
              <div id="cap-global-active" style="font-size:24px;font-weight:700;color:var(--primary);">—</div>
            </div>
            <div style="flex:1;min-width:140px;padding:12px 16px;border-radius:12px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);">
              <div class="small" style="margin-bottom:4px;">Tenant active calls</div>
              <div id="cap-tenant-active" style="font-size:24px;font-weight:700;color:var(--accent);">—</div>
            </div>
          </div>

          <!-- Global limits -->
          <h3 style="margin:0 0 10px;font-size:14px;color:var(--primary);">Global Limits</h3>
          <div style="margin-bottom:16px;">
            <label style="display:flex;justify-content:space-between;"><span>Max concurrent calls (system-wide)</span><span id="cap-global-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">100</span></label>
            <input type="range" id="cap-global-concurrency" min="1" max="500" step="1" value="100" style="width:100%;accent-color:var(--primary);" />
            <div class="small" style="margin-top:2px;">Hard ceiling across all tenants. Set based on server resources.</div>
          </div>

          <!-- Per-tenant limits -->
          <h3 style="margin:0 0 10px;font-size:14px;color:var(--primary);">Per-Tenant Limits <span class="small" style="font-weight:400;">(for selected tenant)</span></h3>
          <div style="margin-bottom:14px;">
            <label style="display:flex;justify-content:space-between;"><span>Max concurrent calls</span><span id="cap-tenant-concurrency-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">10</span></label>
            <input type="range" id="cap-tenant-concurrency" min="1" max="200" step="1" value="10" style="width:100%;accent-color:var(--primary);" />
          </div>
          <div style="margin-bottom:16px;">
            <label style="display:flex;justify-content:space-between;"><span>Max calls per minute</span><span id="cap-tenant-rpm-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">60</span></label>
            <input type="range" id="cap-tenant-rpm" min="1" max="300" step="1" value="60" style="width:100%;accent-color:var(--primary);" />
          </div>

          <!-- Service concurrency -->
          <h3 style="margin:0 0 10px;font-size:14px;color:var(--primary);">Audio Service Concurrency</h3>
          <p class="small" style="margin:0 0 12px;">How many requests each service can process in parallel. Higher values need more GPU/CPU.</p>
          <div style="margin-bottom:14px;">
            <label style="display:flex;justify-content:space-between;"><span>Whisper (STT) concurrent requests</span><span id="cap-whisper-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">2</span></label>
            <input type="range" id="cap-whisper" min="1" max="20" step="1" value="2" style="width:100%;accent-color:var(--primary);" />
          </div>
          <div style="margin-bottom:14px;">
            <label style="display:flex;justify-content:space-between;"><span>Kokoro (TTS) concurrent requests</span><span id="cap-kokoro-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">2</span></label>
            <input type="range" id="cap-kokoro" min="1" max="20" step="1" value="2" style="width:100%;accent-color:var(--primary);" />
          </div>
          <div style="margin-bottom:16px;">
            <label style="display:flex;justify-content:space-between;"><span>XTTS (TTS) concurrent requests</span><span id="cap-xtts-val" style="font-family:'JetBrains Mono',monospace;color:var(--accent);">0</span></label>
            <input type="range" id="cap-xtts" min="0" max="20" step="1" value="0" style="width:100%;accent-color:var(--primary);" />
            <div class="small" style="margin-top:2px;">0 = unlimited (no semaphore). Set a value to prevent GPU overload.</div>
          </div>

          <div class="row" style="gap:8px;">
            <button type="button" id="cap-save">Save capacity settings</button>
            <button type="button" class="secondary" id="cap-refresh">Refresh</button>
          </div>
          <div id="cap-status" class="small" style="margin-top:8px;min-height:16px;"></div>
        </section>
      </div>

      <!-- ── Workflows Tab ── -->
      <div class="tab-content" data-tab="workflows">

        <!-- Workflow Settings -->
        <section class="panel" style="padding:12px 16px;">
          <div style="display:flex; align-items:center; gap:10px;">
            <label for="wf-owner-edit" style="margin:0; cursor:pointer; display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="wf-owner-edit" style="width:18px;height:18px;accent-color:#C9A04E;cursor:pointer;" />
              <span>Allow business owners to create/edit workflows</span>
            </label>
          </div>
          <div style="display:flex; align-items:center; gap:10px; margin-top:10px; padding-top:10px; border-top:1px solid rgba(246,243,236,0.06);">
            <label for="wf-custom-branding" style="margin:0; cursor:pointer; display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="wf-custom-branding" style="width:18px;height:18px;accent-color:#C9A04E;cursor:pointer;" />
              <span>Allow business owners to customize branding</span>
            </label>
            <span class="small muted">(Logo, colors, and company name on PDFs, emails, and documents)</span>
          </div>
        </section>

        <!-- Workflow List -->
        <section class="panel">
          <div class="flex-between">
            <h2>Workflows</h2>
            <div class="row" style="gap:8px;">
              <button type="button" id="wf-new-btn">+ New Workflow</button>
              <button type="button" class="secondary" id="wf-refresh-btn">Refresh</button>
            </div>
          </div>
          <div id="wf-list-empty" class="small muted" style="margin:12px 0;">No workflows yet. Create one to get started.</div>
          <table id="wf-list-table" style="display:none; width:100%; border-collapse:collapse; margin-top:12px;">
            <thead>
              <tr style="text-align:left; border-bottom:1px solid rgba(246,243,236,0.1);">
                <th class="small" style="padding:6px 8px;">Name</th>
                <th class="small" style="padding:6px 8px;">Trigger</th>
                <th class="small" style="padding:6px 8px;">Steps</th>
                <th class="small" style="padding:6px 8px;">Enabled</th>
                <th class="small" style="padding:6px 8px;">Actions</th>
              </tr>
            </thead>
            <tbody id="wf-list-body"></tbody>
          </table>
        </section>

        <!-- Workflow Builder -->
        <section class="panel" id="wf-builder" style="display:none;">
          <h2 id="wf-builder-title">New Workflow</h2>

          <!-- Step 1: Name -->
          <div style="margin:12px 0;">
            <label for="wf-name">Workflow name</label>
            <input id="wf-name" type="text" placeholder="e.g. New lead follow-up" />
          </div>

          <!-- Step 2: Trigger -->
          <div style="margin:12px 0;">
            <label for="wf-trigger-type">Trigger</label>
            <select id="wf-trigger-type" style="width:100%;">
              <option value="call_ended">Call ended</option>
              <option value="after_hours_call">After hours call</option>
              <option value="keyword_detected">Keyword detected</option>
              <option value="missed_call">Missed call</option>
              <option value="scheduled">Scheduled (cron)</option>
            </select>
          </div>

          <!-- Trigger config (dynamic) -->
          <div id="wf-trigger-config" style="margin:12px 0; padding:12px; border-radius:10px; background:rgba(246,243,236,0.04); border:1px solid rgba(246,243,236,0.08);">
            <!-- keyword_detected config -->
            <div id="wf-tc-keywords" style="display:none;">
              <label for="wf-keywords">Keywords (comma-separated)</label>
              <input id="wf-keywords" type="text" placeholder="e.g. emergency, urgent, pricing" />
              <p class="small muted">Workflow fires when any of these words appear in the call transcript.</p>
            </div>
            <!-- after_hours_call config -->
            <div id="wf-tc-after-hours" style="display:none;">
              <div class="row" style="gap:12px;">
                <div>
                  <label for="wf-biz-start">Business hours start</label>
                  <input id="wf-biz-start" type="time" value="09:00" />
                </div>
                <div>
                  <label for="wf-biz-end">Business hours end</label>
                  <input id="wf-biz-end" type="time" value="17:00" />
                </div>
                <div>
                  <label for="wf-tz">Timezone</label>
                  <input id="wf-tz" type="text" value="America/New_York" style="width:180px;" />
                </div>
              </div>
            </div>
            <!-- missed_call config -->
            <div id="wf-tc-missed" style="display:none;">
              <div class="row" style="gap:12px;">
                <div>
                  <label for="wf-max-duration">Max duration (seconds)</label>
                  <input id="wf-max-duration" type="number" value="15" min="1" style="width:100px;" />
                </div>
                <div>
                  <label for="wf-min-turns">Min conversation turns</label>
                  <input id="wf-min-turns" type="number" value="2" min="0" style="width:100px;" />
                </div>
              </div>
            </div>
            <!-- scheduled config -->
            <div id="wf-tc-scheduled" style="display:none;">
              <label for="wf-cron">Cron expression or shortcut</label>
              <input id="wf-cron" type="text" placeholder="e.g. 0 9 * * 1 or @daily" />
              <p class="small muted">Shortcuts: @hourly, @daily, @weekly, @monthly, @every5min, @every15min, @every30min</p>
              <div style="margin-top:8px;">
                <label for="wf-sched-tz">Timezone</label>
                <input id="wf-sched-tz" type="text" value="America/New_York" style="width:200px;" />
              </div>
            </div>
            <!-- call_ended has no additional config -->
            <div id="wf-tc-call-ended">
              <p class="small muted">This workflow fires after every completed call.</p>
            </div>
          </div>

          <!-- Step 3: Action Steps -->
          <div style="margin:12px 0;">
            <div class="flex-between">
              <h3>Action Steps</h3>
              <button type="button" id="wf-add-step" class="secondary" style="font-size:13px;">+ Add Step</button>
            </div>
            <div id="wf-steps-list" style="margin-top:8px;"></div>
            <div id="wf-steps-empty" class="small muted" style="margin:8px 0;">No steps added yet. Add at least one action step.</div>
          </div>

          <!-- Save / Cancel -->
          <div class="row" style="gap:8px; margin-top:16px;">
            <button type="button" id="wf-save-btn">Save Workflow</button>
            <button type="button" class="secondary" id="wf-test-btn">Test (Dry Run)</button>
            <button type="button" class="secondary" id="wf-cancel-btn">Cancel</button>
          </div>
          <div id="wf-builder-status" class="small" style="margin-top:8px; min-height:16px;"></div>
        </section>

        <!-- Run History -->
        <section class="panel">
          <div class="flex-between">
            <h2>Run History</h2>
            <button type="button" class="secondary" id="wf-runs-refresh">Refresh</button>
          </div>
          <div id="wf-runs-empty" class="small muted" style="margin:12px 0;">No workflow runs yet.</div>
          <table id="wf-runs-table" style="display:none; width:100%; border-collapse:collapse; margin-top:12px;">
            <thead>
              <tr style="text-align:left; border-bottom:1px solid rgba(246,243,236,0.1);">
                <th class="small" style="padding:6px 8px;">Workflow</th>
                <th class="small" style="padding:6px 8px;">Trigger</th>
                <th class="small" style="padding:6px 8px;">Status</th>
                <th class="small" style="padding:6px 8px;">Steps</th>
                <th class="small" style="padding:6px 8px;">Started</th>
                <th class="small" style="padding:6px 8px;">Details</th>
              </tr>
            </thead>
            <tbody id="wf-runs-body"></tbody>
          </table>
        </section>

        <!-- Leads -->
        <section class="panel">
          <div class="flex-between">
            <h2>Leads</h2>
            <button type="button" class="secondary" id="wf-leads-refresh">Refresh</button>
          </div>
          <div id="wf-leads-empty" class="small muted" style="margin:12px 0;">No leads captured yet.</div>
          <table id="wf-leads-table" style="display:none; width:100%; border-collapse:collapse; margin-top:12px;">
            <thead>
              <tr style="text-align:left; border-bottom:1px solid rgba(246,243,236,0.1);">
                <th class="small" style="padding:6px 8px;">Name</th>
                <th class="small" style="padding:6px 8px;">Phone</th>
                <th class="small" style="padding:6px 8px;">Email</th>
                <th class="small" style="padding:6px 8px;">Issue</th>
                <th class="small" style="padding:6px 8px;">Priority</th>
                <th class="small" style="padding:6px 8px;">Date</th>
                <th class="small" style="padding:6px 8px;">Actions</th>
              </tr>
            </thead>
            <tbody id="wf-leads-body"></tbody>
          </table>
        </section>
      </div>

    </main>

    <div id="admin-modal" class="modal">
      <div class="modal-card">
        <h3>Admin Access Required</h3>
        <div class="small">Enter an admin token (API key or JWT) to access settings.</div>
        <input id="admin-pass-input" type="password" placeholder="Admin token (API key or JWT)" />
        <div id="admin-pass-error" class="small" style="color: #e07070; min-height: 16px"></div>
        <div class="modal-actions">
          <button type="button" class="secondary" id="admin-pass-cancel">Cancel</button>
          <button type="button" id="admin-pass-confirm">Confirm</button>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      let adminAuthToken = "";
      let currentTenantId = "default";
      let tenantsList = [];
      let adminAuthorized = false;
      let pendingAction = null;
      let adminKeysCache = [];
      let forwardingProfilesCache = [];
      let pricingCache = { items: [], notes: "" };

      function escapeHtml(str) {
        if (str == null) return "";
        const s = String(str);
        return s
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function setStatus(message, type = "ok") {
        const bar = $("status-bar");
        bar.textContent = message;
        bar.classList.remove("ok", "err");
        bar.classList.add(type);
      }

      async function fetchJSON(url, options = {}) {
        try {
          const opts = { ...options };
          const headers = new Headers(opts.headers || {});
          if (!opts.skipTenantHeader && currentTenantId) {
            headers.set("X-Tenant-ID", currentTenantId);
          }
          if (adminAuthToken) {
            headers.set("X-Admin-Key", adminAuthToken);
          }
          opts.headers = headers;
          delete opts.skipTenantHeader;

          const res = await fetch(url, opts);
          if (!res.ok) throw new Error(await res.text());
          return res.json();
        } catch (err) {
          setStatus(`Request failed for ${url}: ${err}`, "err");
          throw err;
        }
      }

      function renderTenantMeta() {
        const meta = tenantsList.find((t) => t.id === currentTenantId);
        if (!meta) {
          $("tenant-meta").textContent = "Choose a business above.";
          return;
        }
        const numbers =
          meta.numbers && meta.numbers.length
            ? `Reception lines: ${meta.numbers.join(", ")}`
            : "No phone numbers yet — add numbers so callers can reach this receptionist.";
        $("tenant-meta").textContent = `${meta.name || meta.id} • ${numbers}`;
      }

      async function loadTenants(preferId) {
        try {
          const data = await fetchJSON("/api/admin/tenants", { skipTenantHeader: true });
          tenantsList = data.tenants || [];
          const select = $("tenant-select");
          if (select) {
            select.innerHTML = "";
            tenantsList.forEach((t) => {
              const opt = document.createElement("option");
              opt.value = t.id;
              opt.textContent = t.name ? `${t.name} (${t.id})` : t.id;
              select.appendChild(opt);
            });
          }

          const preferred =
            (preferId && tenantsList.some((t) => t.id === preferId) && preferId) ||
            (tenantsList.some((t) => t.id === currentTenantId) && currentTenantId) ||
            tenantsList[0]?.id ||
            "default";

          currentTenantId = preferred;
          if (select) select.value = preferred;
          renderTenantMeta();
          setStatus(`Now editing: ${currentTenantId}`, "ok");
        } catch (err) {
          setStatus("Couldn't load businesses: " + err.message, "err");
        }
      }

      async function saveTenantFromForm() {
        const idInput = $("tenant-new-id");
        const numbersInput = $("tenant-new-numbers");
        const id = (idInput?.value || "").trim();
        const numbersRaw = (numbersInput?.value || "").trim();
        if (!id) {
          setStatus("Enter a short ID for this business (e.g. acme-corp).", "err");
          return;
        }
        const numbers =
          numbersRaw.length === 0
            ? []
            : numbersRaw
                .split(/[, \n]+/)
                .map((n) => n.trim())
                .filter(Boolean);
        try {
          await fetchJSON("/api/admin/tenants", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id, name: id, numbers }),
            skipTenantHeader: true,
          });
          await loadTenants(id);
          refreshAll();
          setStatus("Business saved.", "ok");
        } catch (err) {
          setStatus("Couldn't save business: " + err.message, "err");
        }
      }

      async function loadAudit() {
        try {
          const data = await fetchJSON("/api/admin/audit");
          const logs = data.entries || [];
          const lines = logs
            .map(
              (l) =>
                `${l.created_at} | ${l.action} | tenant=${l.tenant_id || "-"} | status=${
                  l.status || "-"
                }`
            )
            .join("\n");
          $("audit-logs").textContent = lines || "No audit entries.";
          setStatus("Audit logs loaded", "ok");
        } catch (err) {
          $("audit-logs").textContent = "Failed to load audit logs: " + err.message;
          setStatus("Audit load failed", "err");
        }
      }

      async function loadAdminKeys() {
        try {
          const data = await fetchJSON("/api/admin/auth/keys");
          adminKeysCache = data.keys || [];
          renderAdminKeys();
          setStatus("Admin keys loaded", "ok");
        } catch (err) {
          $("admin-keys").textContent = "Failed to load admin keys: " + err.message;
          setStatus("Admin keys load failed", "err");
        }
      }

      function renderAdminKeys() {
        const container = $("admin-keys");
        if (!container) return;
        if (!adminKeysCache.length) {
          container.textContent = "No admin keys yet.";
          return;
        }
        container.innerHTML = adminKeysCache
          .map(
            (k) =>
              `${escapeHtml(k.name)} [${escapeHtml(k.role)}] • created ${escapeHtml(k.createdAt || "-")} • last used ${
                escapeHtml(k.lastUsedAt || "-")
              } • id=${escapeHtml(k.id)}`
          )
          .join("\n");
      }

      async function createAdminKey() {
        const name = ($("admin-key-name")?.value || "").trim();
        const role = $("admin-key-role")?.value || "admin";
        if (!name) {
          setStatus("Key name required", "err");
          return;
        }
        try {
          const result = await fetchJSON("/api/admin/auth/keys", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, role }),
          });
          $("admin-key-token").textContent = `New token (copy now): ${result.token}`;
          setStatus("Admin key created", "ok");
          await loadAdminKeys();
        } catch (err) {
          $("admin-key-token").textContent = "";
          setStatus("Admin key creation failed: " + err.message, "err");
        }
      }

      async function deleteAdminKey(id) {
        if (!id) return;
        try {
          await fetchJSON(`/api/admin/auth/keys/${id}`, { method: "DELETE" });
          setStatus("Admin key deleted", "ok");
          await loadAdminKeys();
        } catch (err) {
          setStatus("Admin key delete failed: " + err.message, "err");
        }
      }

      function toggleProviderFields() {
        const isOpenAI = $("provider").value === "openai";
        $("openai-fields").style.display = isOpenAI ? "" : "none";
        $("local-fields").style.display = isOpenAI ? "none" : "";
      }

      function renderConfig(cfg) {
        $("provider").value = cfg.provider;
        $("localUrl").value = cfg.localUrl || "";
        $("openaiModel").value = cfg.openaiModel || "";
        const providerLabel = cfg.provider === "openai" ? "OpenAI (ChatGPT)" : "Local LLM";
        $("summary-provider").textContent = providerLabel;
        $("summary-model").textContent = cfg.provider === "openai"
          ? `Model: ${cfg.openaiModel || "llama3.2:3b"}`
          : cfg.localUrl ? `URL: ${cfg.localUrl}` : "";
        $("api-key-status").textContent = cfg.hasOpenAIApiKey
          ? "API key is configured"
          : "No API key — set one to enable OpenAI";
        $("api-key-status").style.color = cfg.hasOpenAIApiKey ? "var(--primary)" : "#e07070";
        $("debug-config").textContent = JSON.stringify(cfg, null, 2);
        toggleProviderFields();
      }

      async function loadConfig(showStatus = false) {
        try {
          const cfg = await fetchJSON("/api/admin/config");
          renderConfig(cfg);
          if (showStatus) $("config-status").textContent = "Config loaded.";
          setStatus("Config loaded", "ok");
        } catch (err) {
          $("config-status").textContent = "Failed to load config: " + err.message;
          setStatus("Config load failed", "err");
        }
      }

      async function loadPrompts(showStatus = false) {
        try {
          const prompts = await fetchJSON("/api/admin/prompts");
          $("greetingText").value = prompts.greetingText || "";
          $("systemPreamble").value = prompts.systemPreamble || "";
          $("policyPrompt").value = prompts.policyPrompt || "";
          $("voicePrompt").value = prompts.voicePrompt || "";
          $("schemaHint").value = prompts.schemaHint || "";
          if (showStatus) $("prompt-status").textContent = "Prompts loaded.";
          setStatus("Prompts loaded", "ok");
        } catch (err) {
          $("prompt-status").textContent = "Failed to load prompts: " + err.message;
          setStatus("Prompt load failed", "err");
        }
      }

      function showAdminModal() {
        $("admin-pass-input").value = "";
        $("admin-pass-error").textContent = "";
        $("admin-modal").classList.add("active");
        $("admin-pass-input").focus();
      }

      function hideAdminModal() {
        $("admin-modal").classList.remove("active");
      }

      function requestAdminPasscode(actionIfAuthorized) {
        if (adminAuthorized) return true;
        pendingAction = actionIfAuthorized || null;
        showAdminModal();
        return false;
      }

      async function validateAdminToken(token) {
        try {
          const res = await fetch("/api/admin/tenants", {
            headers: { "X-Admin-Key": token }
          });
          return res.ok;
        } catch {
          return false;
        }
      }

      async function handleAdminConfirm() {
        const pass = $("admin-pass-input").value.trim();
        if (!pass) {
          $("admin-pass-error").textContent = "Admin token is required.";
          return;
        }
        $("admin-pass-error").textContent = "Validating...";
        $("admin-pass-confirm").disabled = true;
        const valid = await validateAdminToken(pass);
        $("admin-pass-confirm").disabled = false;
        if (!valid) {
          $("admin-pass-error").textContent = "Invalid admin token. Please try again.";
          return;
        }
        adminAuthToken = pass;
        adminAuthorized = true;
        hideAdminModal();
        setStatus("Admin confirmed", "ok");
        if (typeof pendingAction === "function") {
          const action = pendingAction;
          pendingAction = null;
          action();
        }
      }

      async function saveConfig(event) {
        event.preventDefault();
        if (!adminAuthorized) {
          requestAdminPasscode(() => saveConfig(event));
          return;
        }
        const apiKey = ($("openaiApiKey").value || "").trim();
        const payload = {
          provider: $("provider").value,
          localUrl: $("localUrl").value,
          openaiModel: $("openaiModel").value,
          openaiApiKey: apiKey.length ? apiKey : undefined,
        };
        try {
          const cfg = await fetchJSON("/api/admin/config", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          renderConfig(cfg);
          $("config-status").textContent = cfg.hasOpenAIApiKey ? "Saved. API key stored." : "Saved.";
          loadHealth();
          setStatus("Config saved", "ok");
        } catch (err) {
          $("config-status").textContent = "Save failed: " + err.message;
          setStatus("Config save failed", "err");
        }
      }

      async function savePrompts(event) {
        event.preventDefault();
        if (!adminAuthorized) {
          requestAdminPasscode(() => savePrompts(event));
          return;
        }
        const payload = {
          greetingText: $("greetingText").value,
          systemPreamble: $("systemPreamble").value,
          policyPrompt: $("policyPrompt").value,
          voicePrompt: $("voicePrompt").value,
          schemaHint: $("schemaHint").value,
        };
        try {
          await fetchJSON("/api/admin/prompts", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          $("prompt-status").textContent = "Prompts saved.";
          setStatus("Prompts saved", "ok");
          await loadPrompts();
        } catch (err) {
          $("prompt-status").textContent = "Save failed: " + err.message;
          setStatus("Prompt save failed", "err");
        }
      }

      function pill(text, kind = "ok") {
        const span = document.createElement("span");
        span.className = `pill ${kind}`;
        span.textContent = text;
        return span;
      }

      function pillKind(status) {
        if (status === "ready" || status === "configured" || status === "ok") return "ok";
        if (status === "warn" || status === "missing_api_key" || status === "defaulting") return "warn";
        return "err";
      }

      function renderHealth(data) {
        const container = $("health-status");
        container.innerHTML = "";

        const healthCard = (title, status, lines) => {
          const card = document.createElement("div");
          card.className = "card health-card";
          const header = document.createElement("div");
          header.className = "health-header";
          const name = document.createElement("div");
          name.className = "health-title";
          name.textContent = title;
          const statusPill = pill(status, pillKind(status));
          header.appendChild(name);
          header.appendChild(statusPill);

          const body = document.createElement("div");
          body.className = "health-body";
          lines.forEach((line) => {
            const div = document.createElement("div");
            div.className = "health-line";
            div.textContent = line;
            body.appendChild(div);
          });

          card.appendChild(header);
          card.appendChild(body);
          return card;
        };

        const llmProvider = data.llm.provider === "openai" ? "OpenAI (ChatGPT)" : "Local LLM";
        const llmDetails = data.llm.provider === "openai"
          ? [`Provider: ${llmProvider}`, `Model: ${data.llm.model || "llama3.2:3b"}`, `API Key: ${data.llm.hasOpenAIApiKey ? "Configured" : "Missing"}`]
          : [`Provider: ${llmProvider}`, `URL: ${data.llm.localUrl || "-"}`];
        container.appendChild(
          healthCard("LLM", data.llm.status, llmDetails)
        );

        container.appendChild(healthCard("STT", data.stt.status, [`Status: ${data.stt.status}`]));

        // TTS (Kokoro/XTTS) tuning fields
        container.appendChild(
          healthCard("TTS", data.tts.status, [
            `Status: ${data.tts.status}`,
            `URL: ${data.tts.xttsUrl || "-"}`,
            `Voice: ${data.tts.voiceId || "-"}`,
            `Lang: ${data.tts.language || "-"}`,
            `Rate: ${typeof data.tts.rate === "number" ? data.tts.rate.toFixed(2) : "-"}`,
          ])
        );
      }

      async function loadHealth() {
        try {
          const data = await fetchJSON("/api/admin/health");
          renderHealth(data);
          setStatus("Health loaded", "ok");
          $("debug-health").textContent = JSON.stringify(data, null, 2);
        } catch (err) {
          $("health-status").textContent = "Failed to load health: " + err.message;
          setStatus("Health load failed", "err");
        }
      }

      function renderAnalytics(data) {
        $("summary-calls").textContent = data.totalCalls;
        $("summary-messages").textContent = data.totalCallerMessages;
        $("analytics-summary").innerHTML = `
          <div class="flex-between">
            <div><div class="small">Total calls</div><div class="value">${escapeHtml(data.totalCalls)}</div></div>
            <div><div class="small">Caller messages</div><div class="value">${escapeHtml(data.totalCallerMessages)}</div></div>
          </div>
        `;
        const list = $("top-questions");
        list.innerHTML = "";
        if (!data.topQuestions || data.topQuestions.length === 0) {
          const li = document.createElement("li");
          li.className = "small";
          li.textContent = "No data yet.";
          list.appendChild(li);
          return;
        }
        data.topQuestions.forEach((q) => {
          const li = document.createElement("li");
          li.className = "card";
          li.innerHTML = `<div class="flex-between"><span>${escapeHtml(q.text)}</span><span class="small">x${escapeHtml(q.count)}</span></div>`;
          list.appendChild(li);
        });
      }

      async function loadAnalytics() {
        try {
          const data = await fetchJSON("/api/admin/analytics");
          renderAnalytics(data);
          setStatus("Analytics loaded", "ok");
        } catch (err) {
          $("analytics-summary").textContent = "Failed to load analytics: " + err.message;
          setStatus("Analytics load failed", "err");
        }
      }

      function renderCalls(data) {
        const container = $("calls");
        container.innerHTML = "";
        const callsList = data.calls || [];
        if (callsList.length === 0) {
          container.textContent = "No calls yet.";
          return;
        }
        callsList
          .slice()
          .reverse()
          .forEach((c) => {
            const div = document.createElement("div");
            div.className = "card";
            const lastMessage = c.history?.[c.history.length - 1];
            div.innerHTML = `
              <div class="flex-between">
                <div><strong>${escapeHtml(c.id)}</strong></div>
                <span class="pill ok">${escapeHtml(c.stage)}</span>
              </div>
              <div class="small" style="margin-top: 4px">Caller: ${escapeHtml(c.callerId || "unknown")}</div>
              <div class="small">Lead: ${
                escapeHtml(Object.keys(c.lead || {}).length ? JSON.stringify(c.lead) : "none")
              }</div>
              <div class="small">Last: ${
                lastMessage ? escapeHtml(`${lastMessage.from}: ${lastMessage.message}`) : "n/a"
              }</div>
            `;
            container.appendChild(div);
          });
      }

      async function loadCalls() {
        try {
          const data = await fetchJSON("/api/admin/calls");
          renderCalls(data);
          setStatus("Calls loaded", "ok");
        } catch (err) {
          $("calls").textContent = "Failed to load calls: " + err.message;
          setStatus("Calls load failed", "err");
        }
      }

      // ───────────────────────────────────────────────
      // TTS CONFIG & PREVIEW (Kokoro / XTTS)
      // ───────────────────────────────────────────────

      let currentTtsMode = "coqui_xtts";

      function renderTtsConfig(cfg) {
        const modeEl = $("ttsMode");
        const urlEl = $("ttsUrl");
        const presetEl = $("ttsPreset");
        const voiceEl = $("ttsVoiceId");
        const langEl = $("ttsLanguage");
        const rateEl = $("ttsRate");
        const defaultVoiceModeEl = $("defaultVoiceMode");
        const clonedVoiceUrlEl = $("clonedVoiceUrl");
        const clonedVoiceLabelEl = $("clonedVoiceLabel");

        if (!presetEl || !rateEl) return;

        // Determine TTS mode from config
        currentTtsMode = cfg.mode || cfg.ttsMode || "coqui_xtts";
        if (modeEl) modeEl.value = currentTtsMode;

        // Set URL based on mode
        if (urlEl) {
          urlEl.value = cfg.coquiXttsUrl || cfg.kokoroUrl || cfg.xttsUrl || "";
        }
        presetEl.value = cfg.preset || "neutral";
        
        // Set voice and language from config first
        if (voiceEl) voiceEl.value = cfg.voice || cfg.voiceId || "";
        if (langEl) langEl.value = cfg.language || "";
        
        // If XTTS mode, apply XTTS-appropriate defaults for Kokoro-style values
        if (currentTtsMode === "coqui_xtts") {
          applyXttsDefaults();
        }

        rateEl.value = (typeof cfg.rate === "number" ? cfg.rate : (typeof cfg.coquiSpeed === "number" ? cfg.coquiSpeed : 0.95)).toFixed(2);

        // Voice cloning fields (XTTS only)
        if (defaultVoiceModeEl) {
          defaultVoiceModeEl.value = cfg.defaultVoiceMode || "preset";
        }
        if (clonedVoiceUrlEl) {
          clonedVoiceUrlEl.value = cfg.clonedVoice?.speakerWavUrl || "";
        }
        if (clonedVoiceLabelEl) {
          clonedVoiceLabelEl.value = cfg.clonedVoice?.label || "";
        }

        updateTtsLabels();
        updateVoiceCloningVisibility();
        $("tts-status").textContent = "TTS config loaded.";
      }

      function updateTtsLabels() {
        const rateEl = $("ttsRate");
        const rateVal = $("ttsRateValue");
        if (rateEl && rateVal) rateVal.textContent = Number(rateEl.value).toFixed(2);
      }

      // Kokoro voice IDs typically have patterns like af_alloy, am_echo, bf_emma, etc.
      const KOKORO_VOICE_PATTERN = /^[ab][fm]_/;
      const KOKORO_LANG_VALUES = ["a", "b"];
      const XTTS_DEFAULT_VOICE = "en_sample";
      const XTTS_DEFAULT_LANG = "en";

      function applyXttsDefaults() {
        const voiceEl = $("ttsVoiceId");
        const langEl = $("ttsLanguage");
        
        if (voiceEl) {
          const currentVoice = voiceEl.value.trim();
          // If voice looks like Kokoro format or is empty, apply XTTS default
          if (!currentVoice || KOKORO_VOICE_PATTERN.test(currentVoice)) {
            voiceEl.value = XTTS_DEFAULT_VOICE;
          }
        }
        
        if (langEl) {
          const currentLang = langEl.value.trim();
          // If language is Kokoro-style (a/b) or empty, apply XTTS default
          if (!currentLang || KOKORO_LANG_VALUES.includes(currentLang)) {
            langEl.value = XTTS_DEFAULT_LANG;
          }
        }
      }

      function updateVoiceCloningVisibility() {
        const modeEl = $("ttsMode");
        const voiceCloningSection = $("voice-cloning-section");
        const activeCallPanel = $("active-call-voice-panel");
        const warningEl = $("voice-cloning-warning");
        const defaultVoiceModeEl = $("defaultVoiceMode");
        const clonedVoiceUrlEl = $("clonedVoiceUrl");

        if (!modeEl || !voiceCloningSection) return;

        const isXtts = modeEl.value === "coqui_xtts";
        voiceCloningSection.style.display = isXtts ? "block" : "none";
        if (activeCallPanel) activeCallPanel.style.display = isXtts ? "block" : "none";

        // When XTTS mode is selected, auto-apply XTTS-appropriate defaults
        if (isXtts) {
          applyXttsDefaults();
        }

        // Show warning if cloned mode selected but no URL
        if (warningEl && defaultVoiceModeEl && clonedVoiceUrlEl) {
          const isClonedMode = defaultVoiceModeEl.value === "cloned";
          const hasUrl = clonedVoiceUrlEl.value.trim().length > 0;
          warningEl.style.display = (isClonedMode && !hasUrl) ? "block" : "none";
        }

        currentTtsMode = modeEl.value;
      }

      function validateVoiceCloningConfig() {
        const modeEl = $("ttsMode");
        const defaultVoiceModeEl = $("defaultVoiceMode");
        const clonedVoiceUrlEl = $("clonedVoiceUrl");

        if (!modeEl || modeEl.value !== "coqui_xtts") return true;
        if (!defaultVoiceModeEl || defaultVoiceModeEl.value !== "cloned") return true;
        if (!clonedVoiceUrlEl || clonedVoiceUrlEl.value.trim().length === 0) {
          $("tts-status").textContent = "Error: Cloned voice mode requires a reference audio URL.";
          setStatus("Validation failed: cloned voice URL required", "err");
          return false;
        }
        return true;
      }

      // ========== Audio Recording for Voice Cloning ==========
      let mediaRecorder = null;
      let audioChunks = [];
      let recordingStartTime = null;
      let recordingTimerInterval = null;
      let recordedBlob = null;

      async function startRecording() {
        const recordBtn = $("record-btn");
        const recordBtnText = $("record-btn-text");
        const recordingStatus = $("recording-status");
        const recordingTimer = $("recording-timer");
        const previewContainer = $("audio-preview-container");

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: { 
              channelCount: 1,
              sampleRate: 22050,
              echoCancellation: true,
              noiseSuppression: true
            } 
          });

          // Hide any previous preview
          if (previewContainer) previewContainer.style.display = "none";
          
          audioChunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });

          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
          };

          mediaRecorder.onstop = async () => {
            stream.getTracks().forEach(track => track.stop());
            clearInterval(recordingTimerInterval);
            
            const webmBlob = new Blob(audioChunks, { type: "audio/webm" });
            
            // Convert to WAV
            recordingStatus.textContent = "Converting to WAV...";
            try {
              recordedBlob = await convertToWav(webmBlob);
              showAudioPreview(recordedBlob);
              recordingStatus.textContent = "Recording ready";
            } catch (err) {
              recordingStatus.textContent = "Conversion failed: " + err.message;
              console.error("WAV conversion error:", err);
            }
            
            recordBtnText.textContent = "Record";
            recordBtn.classList.remove("recording");
          };

          mediaRecorder.start(100);
          recordingStartTime = Date.now();
          
          recordBtnText.textContent = "Stop";
          recordBtn.classList.add("recording");
          recordingStatus.textContent = "Recording...";
          
          // Start timer
          recordingTimerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, "0");
            const secs = (elapsed % 60).toString().padStart(2, "0");
            recordingTimer.textContent = `${mins}:${secs}`;
            
            // Auto-stop at 30 seconds
            if (elapsed >= 30) {
              stopRecording();
              recordingStatus.textContent = "Auto-stopped at 30s limit";
            }
          }, 100);

        } catch (err) {
          console.error("Microphone access error:", err);
          recordingStatus.textContent = "Microphone access denied";
          setStatus("Microphone access denied - check browser permissions", "err");
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
      }

      function toggleRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        } else {
          startRecording();
        }
      }

      async function convertToWav(webmBlob) {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });
        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // Get audio data (mono)
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        
        // Create WAV file
        const wavBuffer = encodeWav(channelData, sampleRate);
        return new Blob([wavBuffer], { type: "audio/wav" });
      }

      function encodeWav(samples, sampleRate) {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        
        // WAV header
        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true); // Subchunk1Size
        view.setUint16(20, 1, true);  // AudioFormat (PCM)
        view.setUint16(22, 1, true);  // NumChannels (Mono)
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // ByteRate
        view.setUint16(32, 2, true);  // BlockAlign
        view.setUint16(34, 16, true); // BitsPerSample
        writeString(view, 36, "data");
        view.setUint32(40, samples.length * 2, true);
        
        // Write audio data
        let offset = 44;
        for (let i = 0; i < samples.length; i++) {
          const s = Math.max(-1, Math.min(1, samples[i]));
          view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          offset += 2;
        }
        
        return buffer;
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      function showAudioPreview(blob) {
        const previewContainer = $("audio-preview-container");
        const audioPreview = $("audio-preview");
        
        if (previewContainer && audioPreview) {
          const url = URL.createObjectURL(blob);
          audioPreview.src = url;
          previewContainer.style.display = "block";
        }
      }

      async function useRecording() {
        if (!recordedBlob) {
          setStatus("No recording to upload", "err");
          return;
        }

        const uploadStatus = $("upload-status");
        const clonedVoiceUrlEl = $("clonedVoiceUrl");
        
        if (uploadStatus) {
          uploadStatus.style.display = "block";
          uploadStatus.textContent = "Uploading recording...";
        }

        try {
          const formData = new FormData();
          const filename = `voice-clone-${Date.now()}.wav`;
          formData.append("audio", recordedBlob, filename);

          const response = await fetch("/api/admin/voice-recordings", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            const err = await response.json().catch(() => ({ message: "Upload failed" }));
            throw new Error(err.message || "Upload failed");
          }

          const result = await response.json();
          
          if (clonedVoiceUrlEl && result.url) {
            clonedVoiceUrlEl.value = result.url;
            updateVoiceCloningVisibility();
          }

          if (uploadStatus) {
            uploadStatus.textContent = "Recording uploaded successfully!";
            uploadStatus.style.background = "rgba(201, 160, 78, 0.15)";
          }
          
          setStatus("Voice recording uploaded", "ok");
          
          // Clear the preview after successful upload
          setTimeout(() => {
            discardRecording();
            if (uploadStatus) uploadStatus.style.display = "none";
          }, 2000);

        } catch (err) {
          console.error("Upload error:", err);
          if (uploadStatus) {
            uploadStatus.textContent = "Upload failed: " + err.message;
            uploadStatus.style.background = "rgba(180, 60, 60, 0.15)";
          }
          setStatus("Voice recording upload failed", "err");
        }
      }

      function discardRecording() {
        recordedBlob = null;
        audioChunks = [];
        
        const previewContainer = $("audio-preview-container");
        const audioPreview = $("audio-preview");
        const recordingStatus = $("recording-status");
        const recordingTimer = $("recording-timer");
        
        if (audioPreview) {
          URL.revokeObjectURL(audioPreview.src);
          audioPreview.src = "";
        }
        if (previewContainer) previewContainer.style.display = "none";
        if (recordingStatus) recordingStatus.textContent = "";
        if (recordingTimer) recordingTimer.textContent = "";
      }

      async function loadTtsConfig(showStatus = false) {
        try {
          const cfg = await fetchJSON("/api/tts/config");
          renderTtsConfig(cfg);
          if (showStatus && $("tts-status")) $("tts-status").textContent = "TTS config loaded.";
          setStatus("TTS config loaded", "ok");
        } catch (err) {
          console.error(err);
          if ($("tts-status")) $("tts-status").textContent = "Failed to load TTS config: " + err.message;
          setStatus("TTS config load failed", "err");
        }
      }

      async function saveTtsConfig(event) {
        event.preventDefault();
        if (!adminAuthorized) {
          requestAdminPasscode(() => saveTtsConfig(event));
          return;
        }

        if (!validateVoiceCloningConfig()) return;

        const modeEl = $("ttsMode");
        const urlEl = $("ttsUrl");
        const presetEl = $("ttsPreset");
        const voiceEl = $("ttsVoiceId");
        const langEl = $("ttsLanguage");
        const rateEl = $("ttsRate");
        const defaultVoiceModeEl = $("defaultVoiceMode");
        const clonedVoiceUrlEl = $("clonedVoiceUrl");
        const clonedVoiceLabelEl = $("clonedVoiceLabel");

        if (!presetEl || !rateEl) return;

        const ttsMode = modeEl ? modeEl.value : "coqui_xtts";
        const url = urlEl ? urlEl.value.trim() : undefined;

        const payload = {
          ttsMode,
          preset: presetEl.value,
          voiceId: voiceEl ? voiceEl.value.trim() || undefined : undefined,
          language: langEl ? langEl.value.trim() || undefined : undefined,
          rate: parseFloat(rateEl.value),
        };

        // Set URL based on mode
        if (ttsMode === "coqui_xtts") {
          payload.coquiXttsUrl = url || undefined;
          // Include voice cloning config
          if (defaultVoiceModeEl) {
            payload.defaultVoiceMode = defaultVoiceModeEl.value;
          }
          const clonedUrl = clonedVoiceUrlEl ? clonedVoiceUrlEl.value.trim() : "";
          const clonedLabel = clonedVoiceLabelEl ? clonedVoiceLabelEl.value.trim() : "";
          if (clonedUrl) {
            payload.clonedVoice = {
              speakerWavUrl: clonedUrl,
              label: clonedLabel || undefined,
            };
          }
        } else {
          payload.kokoroUrl = url || undefined;
          payload.xttsUrl = url || undefined; // Legacy compatibility
        }

        try {
          const cfg = await fetchJSON("/api/tts/config", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          renderTtsConfig(cfg);
          $("tts-status").textContent = "Voice settings saved.";
          setStatus("TTS config saved", "ok");
        } catch (err) {
          console.error(err);
          $("tts-status").textContent = "Failed to save TTS config: " + err.message;
          setStatus("TTS config save failed", "err");
        }
      }

      async function previewTts() {
        // TTS preview is not available - it runs in the voice runtime
        $("tts-status").textContent = "Preview not available. TTS is handled by the voice runtime.";
        setStatus("TTS preview runs in voice runtime", "ok");
      }

      // ───────────────────────────────────────────────
      // ACTIVE CALL VOICE CONTROL (Hot-Swap)
      // ───────────────────────────────────────────────

      async function getCallVoiceMode() {
        const callIdEl = $("call-control-id");
        const infoEl = $("call-voice-info");
        const statusEl = $("call-voice-status");

        if (!callIdEl || !infoEl || !statusEl) return;

        const callControlId = callIdEl.value.trim();
        if (!callControlId) {
          statusEl.textContent = "Please enter a Call Control ID.";
          statusEl.style.color = "var(--accent)";
          return;
        }

        statusEl.textContent = "Fetching voice mode...";
        statusEl.style.color = "var(--muted)";

        try {
          const data = await fetchJSON(`/v1/calls/${encodeURIComponent(callControlId)}/voice`);
          
          $("call-voice-mode").textContent = data.voiceMode === "cloned" ? "Cloned Voice" : "Preset Voice";
          $("call-voice-cloning-available").textContent = data.voiceCloningAvailable ? "Yes" : "No";
          $("call-voice-label").textContent = data.clonedVoiceLabel || "—";
          
          infoEl.style.display = "block";
          statusEl.textContent = "Voice mode retrieved.";
          statusEl.style.color = "var(--primary)";
          setStatus("Call voice mode loaded", "ok");
        } catch (err) {
          console.error(err);
          infoEl.style.display = "none";
          statusEl.textContent = "Failed: " + (err.message || "Call not found or ended");
          statusEl.style.color = "var(--danger)";
          setStatus("Call voice mode fetch failed", "err");
        }
      }

      async function setCallVoiceMode() {
        const callIdEl = $("call-control-id");
        const modeEl = $("set-call-voice-mode");
        const urlEl = $("set-call-voice-url");
        const statusEl = $("call-voice-status");

        if (!callIdEl || !modeEl || !statusEl) return;

        const callControlId = callIdEl.value.trim();
        if (!callControlId) {
          statusEl.textContent = "Please enter a Call Control ID.";
          statusEl.style.color = "var(--accent)";
          return;
        }

        const mode = modeEl.value;
        const speakerWavUrl = urlEl ? urlEl.value.trim() : "";

        statusEl.textContent = "Setting voice mode...";
        statusEl.style.color = "var(--muted)";

        const payload = { mode };
        if (speakerWavUrl) payload.speakerWavUrl = speakerWavUrl;

        try {
          const data = await fetchJSON(`/v1/calls/${encodeURIComponent(callControlId)}/voice`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          $("call-voice-mode").textContent = data.voiceMode === "cloned" ? "Cloned Voice" : "Preset Voice";
          $("call-voice-cloning-available").textContent = data.voiceCloningAvailable ? "Yes" : "No";
          $("call-voice-label").textContent = data.clonedVoiceLabel || "—";
          $("call-voice-info").style.display = "block";

          statusEl.textContent = data.updated ? "Voice mode updated!" : "Voice mode set.";
          statusEl.style.color = "var(--primary)";
          setStatus("Call voice mode updated", "ok");
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Failed: " + (err.message || "Invalid mode or call not found");
          statusEl.style.color = "var(--danger)";
          setStatus("Call voice mode update failed", "err");
        }
      }

      // ── Workflow Automation Engine ──

      let workflowsCache = [];
      let workflowRunsCache = [];
      let leadsCache = [];
      let editingWorkflowId = null; // null = new workflow
      let workflowSteps = []; // steps being built in the form

      const TRIGGER_LABELS = {
        call_ended: "Call ended",
        after_hours_call: "After hours call",
        keyword_detected: "Keyword detected",
        missed_call: "Missed call",
        scheduled: "Scheduled",
      };

      const ACTION_LABELS = {
        send_email: "Send Email",
        send_sms: "Send SMS",
        fire_webhook: "Fire Webhook",
        ai_summarize: "AI Summarize",
        ai_extract: "AI Extract Data",
        store_lead: "Store Lead",
      };

      async function loadWorkflows() {
        try {
          const data = await fetchJSON("/api/admin/workflows");
          workflowsCache = data.workflows || [];
          renderWorkflowList();
        } catch (err) {
          console.error("loadWorkflows:", err);
        }
      }

      function renderWorkflowList() {
        const empty = $("wf-list-empty");
        const table = $("wf-list-table");
        const body = $("wf-list-body");
        if (!workflowsCache.length) {
          empty.style.display = "";
          table.style.display = "none";
          return;
        }
        empty.style.display = "none";
        table.style.display = "";
        body.innerHTML = workflowsCache.map(wf => `
          <tr style="border-bottom:1px solid rgba(246,243,236,0.06);">
            <td style="padding:8px;">${escapeHtml(wf.name)}</td>
            <td style="padding:8px;" class="small">${escapeHtml(TRIGGER_LABELS[wf.triggerType] || wf.triggerType)}</td>
            <td style="padding:8px;" class="small">${(wf.steps || []).length} step${(wf.steps || []).length !== 1 ? "s" : ""}</td>
            <td style="padding:8px;">
              <label style="cursor:pointer;display:flex;align-items:center;gap:4px;">
                <input type="checkbox" ${wf.enabled ? "checked" : ""} onchange="toggleWorkflow('${escapeHtml(wf.id)}', this.checked)" style="accent-color:#C9A04E;" />
                <span class="small">${wf.enabled ? "On" : "Off"}</span>
              </label>
            </td>
            <td style="padding:8px;">
              <div class="row" style="gap:4px;">
                <button type="button" onclick="editWorkflow('${escapeHtml(wf.id)}')" style="font-size:12px; padding:3px 10px; border-radius:6px; cursor:pointer;">Edit</button>
                <button type="button" onclick="deleteWorkflowUI('${escapeHtml(wf.id)}')" style="font-size:12px; padding:3px 10px; border-radius:6px; cursor:pointer; background:rgba(196,80,80,0.15); color:#e07070; border:1px solid rgba(196,80,80,0.3);">Delete</button>
              </div>
            </td>
          </tr>
        `).join("");
      }

      async function toggleWorkflow(id, enabled) {
        try {
          await fetchJSON("/api/admin/workflows/" + encodeURIComponent(id), {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ enabled }),
          });
          setStatus(enabled ? "Workflow enabled" : "Workflow disabled", "ok");
          await loadWorkflows();
        } catch (err) {
          setStatus("Toggle failed: " + err.message, "err");
        }
      }

      async function deleteWorkflowUI(id) {
        if (!confirm("Delete this workflow? This cannot be undone.")) return;
        try {
          await fetchJSON("/api/admin/workflows/" + encodeURIComponent(id), { method: "DELETE" });
          setStatus("Workflow deleted", "ok");
          await loadWorkflows();
        } catch (err) {
          setStatus("Delete failed: " + err.message, "err");
        }
      }

      function showWorkflowBuilder(wf) {
        editingWorkflowId = wf ? wf.id : null;
        $("wf-builder").style.display = "";
        $("wf-builder-title").textContent = wf ? "Edit Workflow" : "New Workflow";
        $("wf-name").value = wf ? wf.name : "";
        $("wf-trigger-type").value = wf ? wf.triggerType : "call_ended";
        updateTriggerConfigUI();

        if (wf && wf.triggerConfig) {
          const tc = wf.triggerConfig;
          if (tc.keywords) $("wf-keywords").value = tc.keywords.join(", ");
          if (tc.businessHoursStart) $("wf-biz-start").value = tc.businessHoursStart;
          if (tc.businessHoursEnd) $("wf-biz-end").value = tc.businessHoursEnd;
          if (tc.timezone) { $("wf-tz").value = tc.timezone; if ($("wf-sched-tz")) $("wf-sched-tz").value = tc.timezone; }
          if (tc.maxDurationSeconds) $("wf-max-duration").value = tc.maxDurationSeconds;
          if (tc.minTurns !== undefined) $("wf-min-turns").value = tc.minTurns;
          if (tc.cronExpression) $("wf-cron").value = tc.cronExpression;
        }

        workflowSteps = wf ? [...(wf.steps || [])] : [];
        renderWorkflowSteps();
        $("wf-builder-status").textContent = "";
      }

      function hideWorkflowBuilder() {
        $("wf-builder").style.display = "none";
        editingWorkflowId = null;
        workflowSteps = [];
      }

      function editWorkflow(id) {
        const wf = workflowsCache.find(w => w.id === id);
        if (wf) showWorkflowBuilder(wf);
      }

      function updateTriggerConfigUI() {
        const type = $("wf-trigger-type").value;
        $("wf-tc-keywords").style.display = type === "keyword_detected" ? "" : "none";
        $("wf-tc-after-hours").style.display = type === "after_hours_call" ? "" : "none";
        $("wf-tc-missed").style.display = type === "missed_call" ? "" : "none";
        $("wf-tc-scheduled").style.display = type === "scheduled" ? "" : "none";
        $("wf-tc-call-ended").style.display = type === "call_ended" ? "" : "none";
      }

      function addWorkflowStep() {
        const order = workflowSteps.length + 1;
        workflowSteps.push({ action: "ai_summarize", config: {}, order });
        renderWorkflowSteps();
      }

      function removeWorkflowStep(index) {
        workflowSteps.splice(index, 1);
        workflowSteps.forEach((s, i) => s.order = i + 1);
        renderWorkflowSteps();
      }

      function renderWorkflowSteps() {
        const list = $("wf-steps-list");
        const empty = $("wf-steps-empty");
        if (!workflowSteps.length) {
          empty.style.display = "";
          list.innerHTML = "";
          return;
        }
        empty.style.display = "none";
        list.innerHTML = workflowSteps.map((step, i) => `
          <div style="margin:6px 0; padding:12px; border-radius:10px; background:rgba(246,243,236,0.04); border:1px solid rgba(246,243,236,0.08);">
            <div class="row" style="gap:8px; align-items:center; margin-bottom:8px;">
              <span class="small" style="font-weight:600;">Step ${i + 1}</span>
              <select onchange="updateStepAction(${i}, this.value)" style="min-width:160px;">
                ${Object.entries(ACTION_LABELS).map(([k, v]) =>
                  `<option value="${k}" ${step.action === k ? "selected" : ""}>${v}</option>`
                ).join("")}
              </select>
              <button type="button" onclick="removeWorkflowStep(${i})" style="font-size:12px; padding:3px 10px; border-radius:6px; cursor:pointer; background:rgba(196,80,80,0.15); color:#e07070; border:1px solid rgba(196,80,80,0.3); margin-left:auto;">Remove</button>
            </div>
            <div id="wf-step-config-${i}">${renderStepConfig(step, i)}</div>
          </div>
        `).join("");
      }

      function updateStepAction(index, action) {
        workflowSteps[index].action = action;
        workflowSteps[index].config = {};
        renderWorkflowSteps();
      }

      function renderStepConfig(step, index) {
        const c = step.config || {};
        switch (step.action) {
          case "send_email":
            return `
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <div style="flex:1; min-width:200px;">
                  <label class="small">To (email)</label>
                  <input type="email" value="${escapeHtml(c.to || "")}" onchange="updateStepConfig(${index}, 'to', this.value)" placeholder="recipient@example.com" />
                </div>
                <div style="flex:1; min-width:200px;">
                  <label class="small">Subject</label>
                  <input type="text" value="${escapeHtml(c.subject || "")}" onchange="updateStepConfig(${index}, 'subject', this.value)" placeholder="New call from {{caller}}" />
                </div>
              </div>
              <div style="margin-top:6px;">
                <label class="small">Body</label>
                <textarea rows="3" onchange="updateStepConfig(${index}, 'body', this.value)" placeholder="Call transcript:\n{{transcript}}">${escapeHtml(c.body || "")}</textarea>
              </div>
              <p class="small muted" style="margin-top:4px;">Variables: {{caller}}, {{transcript}}, {{workflow}}, {{timestamp}}, {{step.N.summary}}</p>`;
          case "send_sms":
            return `
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <div style="flex:1; min-width:200px;">
                  <label class="small">To (phone)</label>
                  <input type="tel" value="${escapeHtml(c.to || "")}" onchange="updateStepConfig(${index}, 'to', this.value)" placeholder="+15555555555" />
                </div>
              </div>
              <div style="margin-top:6px;">
                <label class="small">Message</label>
                <textarea rows="2" onchange="updateStepConfig(${index}, 'message', this.value)" placeholder="New call from {{caller}}: {{step.1.summary}}">${escapeHtml(c.message || "")}</textarea>
              </div>`;
          case "fire_webhook":
            return `
              <div class="row" style="gap:8px; flex-wrap:wrap;">
                <div style="flex:1; min-width:250px;">
                  <label class="small">URL</label>
                  <input type="url" value="${escapeHtml(c.url || "")}" onchange="updateStepConfig(${index}, 'url', this.value)" placeholder="https://hooks.example.com/veralux" />
                </div>
                <div style="min-width:150px;">
                  <label class="small">HMAC Secret (optional)</label>
                  <input type="text" value="${escapeHtml(c.secret || "")}" onchange="updateStepConfig(${index}, 'secret', this.value)" placeholder="signing-secret" />
                </div>
              </div>
              <div class="row" style="gap:8px; margin-top:6px;">
                <label class="small" style="display:flex;align-items:center;gap:4px;">
                  <input type="checkbox" ${c.includeTranscript !== false ? "checked" : ""} onchange="updateStepConfig(${index}, 'includeTranscript', this.checked)" /> Include transcript
                </label>
                <label class="small" style="display:flex;align-items:center;gap:4px;">
                  <input type="checkbox" ${c.includeStepOutputs ? "checked" : ""} onchange="updateStepConfig(${index}, 'includeStepOutputs', this.checked)" /> Include previous step outputs
                </label>
              </div>`;
          case "ai_summarize":
            return `
              <div>
                <label class="small">Custom prompt (optional)</label>
                <textarea rows="2" onchange="updateStepConfig(${index}, 'prompt', this.value)" placeholder="Summarize this call including key points, action items, and follow-ups.">${escapeHtml(c.prompt || "")}</textarea>
              </div>`;
          case "ai_extract":
            return `
              <div>
                <label class="small">Fields to extract (comma-separated)</label>
                <input type="text" value="${escapeHtml((c.fields || []).join(", "))}" onchange="updateStepConfig(${index}, 'fields', this.value.split(',').map(f=>f.trim()).filter(Boolean))" placeholder="name, phone, email, issue, category, priority" />
              </div>
              <div style="margin-top:6px;">
                <label class="small">Custom prompt (optional)</label>
                <textarea rows="2" onchange="updateStepConfig(${index}, 'prompt', this.value)" placeholder="">${escapeHtml(c.prompt || "")}</textarea>
              </div>`;
          case "store_lead":
            return `
              <div class="row" style="gap:8px;">
                <div>
                  <label class="small">Use data from step #</label>
                  <input type="number" min="1" value="${c.fromStep || ""}" onchange="updateStepConfig(${index}, 'fromStep', parseInt(this.value) || undefined)" style="width:80px;" placeholder="e.g. 2" />
                </div>
                <div style="flex:1;">
                  <label class="small">Default priority</label>
                  <select onchange="updateStepConfig(${index}, 'priority', this.value)">
                    <option value="normal" ${(c.priority || "normal") === "normal" ? "selected" : ""}>Normal</option>
                    <option value="high" ${c.priority === "high" ? "selected" : ""}>High</option>
                    <option value="low" ${c.priority === "low" ? "selected" : ""}>Low</option>
                    <option value="urgent" ${c.priority === "urgent" ? "selected" : ""}>Urgent</option>
                  </select>
                </div>
              </div>
              <p class="small muted" style="margin-top:4px;">If "from step" is set, extracted data from that ai_extract step will be used to populate the lead.</p>`;
          default:
            return `<p class="small muted">No configuration needed.</p>`;
        }
      }

      function updateStepConfig(index, key, value) {
        if (!workflowSteps[index].config) workflowSteps[index].config = {};
        workflowSteps[index].config[key] = value;
      }

      function gatherTriggerConfig() {
        const type = $("wf-trigger-type").value;
        const cfg = {};
        switch (type) {
          case "keyword_detected":
            cfg.keywords = ($("wf-keywords").value || "").split(",").map(k => k.trim()).filter(Boolean);
            break;
          case "after_hours_call":
            cfg.businessHoursStart = $("wf-biz-start").value || "09:00";
            cfg.businessHoursEnd = $("wf-biz-end").value || "17:00";
            cfg.timezone = $("wf-tz").value || "America/New_York";
            break;
          case "missed_call":
            cfg.maxDurationSeconds = parseInt($("wf-max-duration").value) || 15;
            cfg.minTurns = parseInt($("wf-min-turns").value) || 2;
            break;
          case "scheduled":
            cfg.cronExpression = $("wf-cron").value.trim();
            cfg.timezone = $("wf-sched-tz").value || "America/New_York";
            break;
        }
        return cfg;
      }

      async function saveWorkflow() {
        const statusEl = $("wf-builder-status");
        const name = $("wf-name").value.trim();
        if (!name) { statusEl.textContent = "Name is required."; return; }
        if (!workflowSteps.length) { statusEl.textContent = "Add at least one action step."; return; }

        const payload = {
          name,
          triggerType: $("wf-trigger-type").value,
          triggerConfig: gatherTriggerConfig(),
          steps: workflowSteps,
        };

        try {
          if (editingWorkflowId) {
            await fetchJSON("/api/admin/workflows/" + encodeURIComponent(editingWorkflowId), {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            setStatus("Workflow updated", "ok");
          } else {
            await fetchJSON("/api/admin/workflows", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            setStatus("Workflow created", "ok");
          }
          hideWorkflowBuilder();
          await loadWorkflows();
        } catch (err) {
          statusEl.textContent = "Save failed: " + err.message;
        }
      }

      async function testWorkflow() {
        const statusEl = $("wf-builder-status");
        if (!editingWorkflowId) {
          statusEl.textContent = "Save the workflow first, then test it.";
          return;
        }
        try {
          statusEl.textContent = "Running dry run…";
          const result = await fetchJSON("/api/admin/workflows/" + encodeURIComponent(editingWorkflowId) + "/test", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}),
          });
          const stepSummary = (result.steps || []).map(s =>
            `${s.action}: ${s.status}${s.error ? " (" + s.error + ")" : ""}`
          ).join(", ");
          statusEl.textContent = "Dry run: " + stepSummary;
          setStatus("Dry run completed", "ok");
        } catch (err) {
          statusEl.textContent = "Test failed: " + err.message;
        }
      }

      // ── Run History ──

      async function loadWorkflowRuns() {
        try {
          const data = await fetchJSON("/api/admin/workflow-runs?limit=50");
          workflowRunsCache = data.runs || [];
          renderWorkflowRuns();
        } catch (err) {
          console.error("loadWorkflowRuns:", err);
        }
      }

      function renderWorkflowRuns() {
        const empty = $("wf-runs-empty");
        const table = $("wf-runs-table");
        const body = $("wf-runs-body");
        if (!workflowRunsCache.length) {
          empty.style.display = "";
          table.style.display = "none";
          return;
        }
        empty.style.display = "none";
        table.style.display = "";
        body.innerHTML = workflowRunsCache.map(run => {
          const wf = workflowsCache.find(w => w.id === run.workflowId);
          const statusColors = { completed: "#4CAF50", failed: "#e07070", running: "#C9A04E", pending: "#888" };
          const statusColor = statusColors[run.status] || "#888";
          const trigger = run.triggerEvent?.type || "—";
          const started = run.startedAt ? new Date(run.startedAt).toLocaleString() : "—";
          return `
            <tr style="border-bottom:1px solid rgba(246,243,236,0.06);">
              <td style="padding:8px;" class="small">${escapeHtml(wf?.name || run.workflowId.slice(0, 8))}</td>
              <td style="padding:8px;" class="small">${escapeHtml(TRIGGER_LABELS[trigger] || trigger)}</td>
              <td style="padding:8px;"><span style="color:${statusColor}; font-weight:600;" class="small">${escapeHtml(run.status)}</span></td>
              <td style="padding:8px;" class="small">${run.stepsCompleted}/${run.stepsTotal}</td>
              <td style="padding:8px;" class="small">${escapeHtml(started)}</td>
              <td style="padding:8px;">
                <button type="button" onclick='showRunDetails(${JSON.stringify(run).replace(/'/g, "\\'")})'
                  style="font-size:11px; padding:2px 8px; border-radius:4px; cursor:pointer;">Details</button>
              </td>
            </tr>`;
        }).join("");
      }

      function showRunDetails(run) {
        const details = (run.result || []).map(r =>
          `Step ${r.order} (${r.action}): ${r.status}${r.error ? " — " + r.error : ""}${r.durationMs ? " (" + r.durationMs + "ms)" : ""}`
        ).join("\n");
        alert("Run Details:\n\nStatus: " + run.status + "\nError: " + (run.error || "none") + "\n\n" + (details || "No step results."));
      }

      // ── Leads ──

      async function loadLeads() {
        try {
          const data = await fetchJSON("/api/admin/leads?limit=100");
          leadsCache = data.leads || [];
          renderLeads();
        } catch (err) {
          console.error("loadLeads:", err);
        }
      }

      function renderLeads() {
        const empty = $("wf-leads-empty");
        const table = $("wf-leads-table");
        const body = $("wf-leads-body");
        if (!leadsCache.length) {
          empty.style.display = "";
          table.style.display = "none";
          return;
        }
        empty.style.display = "none";
        table.style.display = "";
        body.innerHTML = leadsCache.map(lead => {
          const priorityColors = { urgent: "#e07070", high: "#C9A04E", normal: "#aaa", low: "#666" };
          const pColor = priorityColors[lead.priority] || "#aaa";
          const date = lead.createdAt ? new Date(lead.createdAt).toLocaleDateString() : "—";
          return `
            <tr style="border-bottom:1px solid rgba(246,243,236,0.06);">
              <td style="padding:8px;" class="small">${escapeHtml(lead.name || "—")}</td>
              <td style="padding:8px;" class="small">${escapeHtml(lead.phone || "—")}</td>
              <td style="padding:8px;" class="small">${escapeHtml(lead.email || "—")}</td>
              <td style="padding:8px;" class="small">${escapeHtml(lead.issue || "—")}</td>
              <td style="padding:8px;"><span style="color:${pColor};" class="small">${escapeHtml(lead.priority || "normal")}</span></td>
              <td style="padding:8px;" class="small">${escapeHtml(date)}</td>
              <td style="padding:8px;">
                <button type="button" onclick="deleteLeadUI('${escapeHtml(lead.id)}')"
                  style="font-size:11px; padding:2px 8px; border-radius:4px; cursor:pointer; background:rgba(196,80,80,0.15); color:#e07070; border:1px solid rgba(196,80,80,0.3);">Delete</button>
              </td>
            </tr>`;
        }).join("");
      }

      async function deleteLeadUI(id) {
        if (!confirm("Delete this lead?")) return;
        try {
          await fetchJSON("/api/admin/leads/" + encodeURIComponent(id), { method: "DELETE" });
          setStatus("Lead deleted", "ok");
          await loadLeads();
        } catch (err) {
          setStatus("Delete failed: " + err.message, "err");
        }
      }

      // ── Workflow Settings ──

      async function loadWorkflowSettings() {
        try {
          const settings = await fetchJSON("/api/admin/workflows/settings");
          $("wf-owner-edit").checked = settings.ownerCanEdit === true;
          $("wf-custom-branding").checked = settings.customBrandingEnabled === true;
        } catch (err) {
          console.error("loadWorkflowSettings:", err);
        }
      }

      function refreshAll() {
        setStatus("Refreshing…", "ok");
        loadConfig();
        loadPrompts();
        loadForwardingAndPricing();
        loadTtsConfig();
        loadHealth();
        loadAnalytics();
        loadCalls();
        loadAudit();
        loadAdminKeys();
        loadCloudflareStatus();
        loadSubscription();
        loadWorkflows();
        loadWorkflowRuns();
        loadLeads();
        loadWorkflowSettings();
        loadCapacity();
      }

      // ── Subscription / Billing ──

      async function loadSubscription() {
        try {
          const sub = await fetchJSON("/api/admin/subscription");
          const hasData = sub.configured !== false;
          // Always populate the toggle
          $("sub-show-portal").checked = hasData ? sub.showBillingPortal !== false : false;
          // Populate manual form fields (used when Stripe is not connected)
          if ($("sub-plan")) $("sub-plan").value = hasData ? (sub.planName || "") : "";
          if ($("sub-status")) $("sub-status").value = hasData ? (sub.status || "trial") : "trial";
          if ($("sub-price")) $("sub-price").value = hasData && sub.priceCents ? (sub.priceCents / 100).toFixed(2) : "";
          if ($("sub-currency")) $("sub-currency").value = hasData ? (sub.currency || "usd") : "usd";
          if ($("sub-frequency")) $("sub-frequency").value = hasData ? (sub.billingFrequency || "monthly") : "monthly";
          if ($("sub-card-brand")) $("sub-card-brand").value = hasData ? (sub.paymentMethodBrand || "") : "";
          if ($("sub-card-last4")) $("sub-card-last4").value = hasData ? (sub.paymentMethodLast4 || "") : "";
          if ($("sub-notes")) $("sub-notes").value = hasData ? (sub.adminNotes || "") : "";
          if (hasData && sub.nextBillingDate && $("sub-next-billing")) $("sub-next-billing").value = sub.nextBillingDate.slice(0, 10);
          else if ($("sub-next-billing")) $("sub-next-billing").value = "";
          if (hasData && sub.trialEndsAt && $("sub-trial-ends")) $("sub-trial-ends").value = sub.trialEndsAt.slice(0, 10);
          else if ($("sub-trial-ends")) $("sub-trial-ends").value = "";
          // Populate read-only summary and Stripe IDs
          if (hasData) {
            renderSubscriptionSummary(sub);
            $("sub-summary").style.display = "";
          } else {
            $("sub-summary").style.display = "none";
          }
          // Load Stripe status (toggles which panels are visible)
          loadStripeStatus();
        } catch (err) {
          console.error("loadSubscription:", err);
        }
      }

      async function saveSubscription() {
        const statusEl = $("sub-status-msg");
        try {
          const payload = {
            planName: $("sub-plan").value.trim() || "Starter",
            priceCents: Math.round((parseFloat($("sub-price").value) || 0) * 100),
            currency: $("sub-currency").value,
            billingFrequency: $("sub-frequency").value,
            status: $("sub-status").value,
            showBillingPortal: $("sub-show-portal").checked,
            paymentMethodBrand: $("sub-card-brand").value || null,
            paymentMethodLast4: $("sub-card-last4").value || null,
            nextBillingDate: $("sub-next-billing").value ? new Date($("sub-next-billing").value).toISOString() : null,
            trialEndsAt: $("sub-trial-ends").value ? new Date($("sub-trial-ends").value).toISOString() : null,
            adminNotes: $("sub-notes").value.trim() || null,
          };
          await fetchJSON("/api/admin/subscription", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (statusEl) statusEl.textContent = "Saved.";
          setStatus("Subscription saved", "ok");
        } catch (err) {
          if (statusEl) statusEl.textContent = "Save failed: " + err.message;
          setStatus("Subscription save failed", "err");
        }
      }

      // ── Stripe ──

      let stripeIsConnected = false;

      async function loadStripeStatus() {
        try {
          const status = await fetchJSON("/api/admin/stripe/status");
          const bar = $("stripe-status-bar");
          stripeIsConnected = !!status.configured;
          if (stripeIsConnected) {
            bar.innerHTML = '<span style="color:var(--primary);">&#10003; Stripe is connected — payments are processed through Stripe</span>';
            bar.style.background = "rgba(201,160,78,0.08)";
            bar.style.border = "1px solid rgba(201,160,78,0.2)";
            // Show Stripe controls, hide manual form
            $("stripe-section").style.display = "";
            $("stripe-configured").style.display = "";
            $("stripe-admin-extras").style.display = "";
            $("manual-billing-section").style.display = "none";
            $("sub-summary").style.display = "";
            await loadStripePlans();
          } else {
            bar.innerHTML = 'Stripe is not connected — using manual billing. Add <code>STRIPE_SECRET_KEY</code> to .env to enable payment processing.';
            bar.style.background = "rgba(246,243,236,0.06)";
            bar.style.border = "1px solid rgba(246,243,236,0.1)";
            // Show manual form, hide Stripe controls
            $("stripe-section").style.display = "none";
            $("stripe-admin-extras").style.display = "none";
            $("manual-billing-section").style.display = "";
            $("sub-summary").style.display = "none";
          }
        } catch (err) {
          console.error("loadStripeStatus:", err);
        }
      }

      function renderSubscriptionSummary(sub) {
        if (!sub) return;
        const statusMap = { trial: "Trial", active: "Active", past_due: "Past due", paused: "Paused", cancelled: "Cancelled" };
        const freqMap = { monthly: "Monthly", quarterly: "Quarterly", yearly: "Yearly", one_time: "One-time" };
        $("sub-summary-plan").textContent = sub.planName || "—";
        $("sub-summary-status").textContent = statusMap[sub.status] || sub.status || "—";
        const price = sub.priceCents ? "$" + (sub.priceCents / 100).toFixed(2) : "—";
        $("sub-summary-price").textContent = price + " " + (sub.currency || "usd").toUpperCase();
        $("sub-summary-freq").textContent = freqMap[sub.billingFrequency] || sub.billingFrequency || "—";
        $("sub-summary-next").textContent = sub.nextBillingDate ? new Date(sub.nextBillingDate).toLocaleDateString() : "—";
        const card = sub.paymentMethodBrand && sub.paymentMethodLast4
          ? `${sub.paymentMethodBrand.charAt(0).toUpperCase() + sub.paymentMethodBrand.slice(1)} ····${sub.paymentMethodLast4}`
          : "None";
        $("sub-summary-card").textContent = card;
        // Stripe IDs
        if ($("stripe-cust-id")) $("stripe-cust-id").textContent = sub.stripeCustomerId || "—";
        if ($("stripe-sub-id")) $("stripe-sub-id").textContent = sub.stripeSubscriptionId || "—";
        if ($("stripe-price-id")) $("stripe-price-id").textContent = sub.stripePriceId || "—";
        // Stripe admin notes
        if ($("sub-notes-stripe")) $("sub-notes-stripe").value = sub.adminNotes || "";
      }

      let stripePlansCache = [];

      async function loadStripePlans() {
        try {
          const data = await fetchJSON("/api/admin/stripe/plans");
          stripePlansCache = data.plans || [];
          renderStripePlans();
          renderStripePlanSelect();
        } catch (err) {
          console.error("loadStripePlans:", err);
        }
      }

      function renderStripePlans() {
        const list = $("stripe-plans-list");
        if (!list) return;
        if (!stripePlansCache.length) {
          list.innerHTML = '<li class="small" style="color:var(--muted)">No plans yet. Create one above.</li>';
          return;
        }
        const intervalLabels = { month: "Monthly", quarter: "Quarterly", year: "Yearly", one_time: "One-time", monthly: "Monthly", quarterly: "Quarterly", yearly: "Yearly" };
        list.innerHTML = stripePlansCache.map(p => {
          const intv = intervalLabels[p.billing_interval] || p.billing_interval;
          return `<li style="margin:4px 0; padding:8px 10px; border-radius:8px; background:rgba(246,243,236,0.04); border:1px solid rgba(246,243,236,0.08); display:flex; justify-content:space-between; align-items:center; gap:8px;">
            <span style="flex:1;"><strong>${escapeHtml(p.name)}</strong> — $${(p.price_cents / 100).toFixed(2)} ${p.currency.toUpperCase()} / ${intv}</span>
            <code class="small" style="flex-shrink:0;">${escapeHtml(p.stripe_price_id || "—")}</code>
            <button type="button" onclick="deleteStripePlanUI('${escapeHtml(p.id)}')" style="background:rgba(196,80,80,0.15); color:#e07070; border:1px solid rgba(196,80,80,0.3); padding:3px 10px; border-radius:6px; font-size:12px; cursor:pointer; flex-shrink:0;">Delete</button>
          </li>`;
        }).join("");
      }

      function renderStripePlanSelect() {
        const sel = $("stripe-assign-plan");
        if (!sel) return;
        const intervalLabels = { month: "Monthly", quarter: "Quarterly", year: "Yearly", one_time: "One-time", monthly: "Monthly", quarterly: "Quarterly", yearly: "Yearly" };
        sel.innerHTML = '<option value="">Select a plan…</option>';
        stripePlansCache.forEach(p => {
          const intv = intervalLabels[p.billing_interval] || p.billing_interval;
          const opt = document.createElement("option");
          opt.value = p.stripe_price_id;
          opt.textContent = `${p.name} — $${(p.price_cents / 100).toFixed(2)} / ${intv}`;
          sel.appendChild(opt);
        });
      }

      function renderStripeIds() {
        // Show Stripe IDs from the loaded subscription
        const sub = {
          customerId: $("stripe-cust-id")?.dataset?.value,
          subscriptionId: $("stripe-sub-id")?.dataset?.value,
          priceId: $("stripe-price-id")?.dataset?.value,
        };
      }

      async function createStripePlan() {
        const name = $("stripe-plan-name").value.trim();
        const priceDollars = parseFloat($("stripe-plan-price").value) || 0;
        const priceCents = Math.round(priceDollars * 100);
        const billingInterval = $("stripe-plan-interval").value;
        if (!name || !priceCents) return;
        try {
          await fetchJSON("/api/admin/stripe/plans", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, priceCents, billingInterval }),
          });
          $("stripe-plan-name").value = "";
          $("stripe-plan-price").value = "";
          setStatus("Stripe plan created", "ok");
          await loadStripePlans();
        } catch (err) {
          setStatus("Failed to create plan: " + err.message, "err");
        }
      }

      async function deleteStripePlanUI(planId) {
        if (!confirm("Delete this plan? It will be deactivated in Stripe and removed from the list.")) return;
        try {
          await fetchJSON("/api/admin/stripe/plans/" + encodeURIComponent(planId), { method: "DELETE" });
          setStatus("Plan deleted", "ok");
          await loadStripePlans();
        } catch (err) {
          setStatus("Failed to delete plan: " + err.message, "err");
        }
      }

      async function removeSubscription() {
        if (!confirm("Remove this tenant's subscription? The billing section will be hidden from the owner.")) return;
        try {
          await fetchJSON("/api/admin/subscription", { method: "DELETE" });
          setStatus("Subscription removed", "ok");
          $("sub-show-portal").checked = false;
          await loadSubscription();
        } catch (err) {
          setStatus("Failed to remove: " + err.message, "err");
        }
      }

      async function assignStripePlan() {
        const priceId = $("stripe-assign-plan").value;
        const statusEl = $("stripe-action-status");
        if (!priceId) { if (statusEl) statusEl.textContent = "Select a plan first."; return; }

        // Find the selected plan from cache to get its details
        const plan = stripePlansCache.find(p => p.stripe_price_id === priceId);
        if (!plan) { if (statusEl) statusEl.textContent = "Plan not found."; return; }

        const intervalLabels = { month: "monthly", quarter: "quarterly", year: "yearly", one_time: "one_time", monthly: "monthly", quarterly: "quarterly", yearly: "yearly" };
        try {
          await fetchJSON("/api/admin/subscription", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              planName: plan.name,
              priceCents: plan.price_cents,
              currency: plan.currency || "usd",
              billingFrequency: intervalLabels[plan.billing_interval] || plan.billing_interval,
              status: "active",
              showBillingPortal: $("sub-show-portal").checked,
              stripePriceId: plan.stripe_price_id || null,
              stripeProductId: plan.stripe_product_id || null,
            }),
          });
          if (statusEl) statusEl.textContent = "Plan assigned and saved.";
          setStatus("Plan assigned to tenant", "ok");
          await loadSubscription();
        } catch (err) {
          if (statusEl) statusEl.textContent = "Failed: " + err.message;
        }
      }

      async function stripeCheckout() {
        const priceId = $("stripe-assign-plan").value;
        const statusEl = $("stripe-action-status");
        if (!priceId) { if (statusEl) statusEl.textContent = "Select a plan first."; return; }
        try {
          const data = await fetchJSON("/api/admin/stripe/checkout", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ priceId }),
          });
          const urlEl = $("stripe-checkout-url");
          if (urlEl && data.url) {
            urlEl.style.display = "";
            urlEl.innerHTML = `Checkout link: <a href="${escapeHtml(data.url)}" target="_blank" style="color:var(--primary); word-break:break-all;">${escapeHtml(data.url)}</a>`;
          }
          if (statusEl) statusEl.textContent = "Checkout session created. Send the link to the owner.";
          setStatus("Stripe checkout created", "ok");
        } catch (err) {
          if (statusEl) statusEl.textContent = "Failed: " + err.message;
        }
      }

      async function stripePortal() {
        const statusEl = $("stripe-action-status");
        try {
          const data = await fetchJSON("/api/admin/stripe/portal", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}),
          });
          if (data.url) window.open(data.url, "_blank");
          if (statusEl) statusEl.textContent = "Portal opened in new tab.";
        } catch (err) {
          if (statusEl) statusEl.textContent = "Failed: " + err.message;
        }
      }

      async function stripeSync() {
        const statusEl = $("stripe-action-status");
        try {
          const data = await fetchJSON("/api/admin/stripe/sync", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}),
          });
          if (statusEl) statusEl.textContent = "Synced from Stripe.";
          setStatus("Subscription synced from Stripe", "ok");
          await loadSubscription();
        } catch (err) {
          if (statusEl) statusEl.textContent = "Sync failed: " + err.message;
        }
      }

      async function loadForwardingAndPricing() {
        try {
          const [profilesRes, pricingRes] = await Promise.all([
            fetchJSON("/api/admin/forwarding-profiles"),
            fetchJSON("/api/admin/pricing"),
          ]);
          forwardingProfilesCache = Array.isArray(profilesRes?.profiles) ? profilesRes.profiles : [];
          pricingCache = pricingRes && typeof pricingRes === "object"
            ? { items: Array.isArray(pricingRes.items) ? pricingRes.items : [], notes: pricingRes.notes || "" }
            : { items: [], notes: "" };
          renderForwardingProfiles();
          renderPricing();
        } catch (err) {
          setStatus("Forwarding/pricing load failed: " + err.message, "err");
        }
      }

      function renderForwardingProfiles() {
        const list = $("forwarding-profiles-list");
        if (!list) return;
        list.innerHTML = "";
        if (forwardingProfilesCache.length === 0) {
          list.appendChild(Object.assign(document.createElement("li"), { className: "small", textContent: "No profiles yet. Add one above." }));
          return;
        }
        forwardingProfilesCache.forEach((p, i) => {
          const li = document.createElement("li");
          li.className = "card";
          li.style.marginBottom = "6px";
          li.innerHTML = `
            <div class="flex-between">
              <div>
                <strong>${escapeHtml(p.name)}</strong> ${escapeHtml(p.number)} <span class="small" style="color:var(--accent,#C9A04E)">${escapeHtml(p.role)}</span>${p.description ? ` &mdash; <span class="small">${escapeHtml(p.description)}</span>` : ""}
              </div>
              <button type="button" class="secondary" data-fp-index="${i}">Remove</button>
            </div>
          `;
          li.querySelector("button").addEventListener("click", () => {
            forwardingProfilesCache.splice(i, 1);
            renderForwardingProfiles();
          });
          list.appendChild(li);
        });
      }

      function renderPricing() {
        const list = $("pricing-items-list");
        const notesEl = $("pricing-notes");
        if (!list) return;
        if (notesEl) notesEl.value = pricingCache.notes || "";
        list.innerHTML = "";
        if (!pricingCache.items || pricingCache.items.length === 0) {
          list.appendChild(Object.assign(document.createElement("li"), { className: "small", textContent: "No items yet. Add one above." }));
          return;
        }
        pricingCache.items.forEach((item, i) => {
          const li = document.createElement("li");
          li.className = "card";
          li.style.marginBottom = "6px";
          const badge = (item.type === "product")
            ? '<span style="background:rgba(201,160,78,0.18);color:#C9A04E;padding:2px 8px;border-radius:999px;font-size:11px;font-weight:700;margin-right:6px;">Product</span>'
            : '<span style="background:rgba(246,243,236,0.10);color:var(--muted);padding:2px 8px;border-radius:999px;font-size:11px;font-weight:700;margin-right:6px;">Service</span>';
          li.innerHTML = `
            <div class="flex-between">
              <div>${badge}<strong>${escapeHtml(item.name)}</strong> ${escapeHtml(item.price)} ${item.description ? `<span class="small">${escapeHtml(item.description)}</span>` : ""}</div>
              <button type="button" class="secondary" data-price-index="${i}">Remove</button>
            </div>
          `;
          li.querySelector("button").addEventListener("click", () => {
            pricingCache.items.splice(i, 1);
            renderPricing();
          });
          list.appendChild(li);
        });
      }

      async function saveForwardingProfiles() {
        const status = $("fp-status");
        try {
          await fetchJSON("/api/admin/forwarding-profiles", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ profiles: forwardingProfilesCache }),
          });
          if (status) status.textContent = "Saved.";
          setStatus("Forwarding profiles saved", "ok");
        } catch (err) {
          if (status) status.textContent = "Save failed: " + err.message;
          setStatus("Forwarding save failed", "err");
        }
      }

      async function savePricing() {
        const notesEl = $("pricing-notes");
        if (notesEl) pricingCache.notes = notesEl.value.trim();
        const status = $("price-status");
        try {
          await fetchJSON("/api/admin/pricing", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(pricingCache),
          });
          if (status) status.textContent = "Saved.";
          setStatus("Pricing saved", "ok");
        } catch (err) {
          if (status) status.textContent = "Save failed: " + err.message;
          setStatus("Pricing save failed", "err");
        }
      }

      /* ── Cloudflare Tunnel ─────────────────────── */
      async function loadCloudflareStatus() {
        // Load token status
        try {
          const tokenData = await fetchJSON("/api/admin/cloudflare/token");
          const tokenStatus = $("cf-token-status");
          if (tokenData.hasToken) {
            tokenStatus.innerHTML = '<span style="color: var(--primary);">&#10003; Tunnel token is configured.</span>';
          } else {
            tokenStatus.textContent = "No tunnel token set.";
          }
        } catch {
          $("cf-token-status").textContent = "Could not load token status.";
        }

        // Load container status
        try {
          const data = await fetchJSON("/api/admin/cloudflare/status");
          const dot = $("cf-status-dot");
          const text = $("cf-status-text");
          const detail = $("cf-status-detail");
          if (!data.exists) {
            dot.style.background = "#666";
            text.textContent = "Not found";
            detail.textContent = data.message || "Container does not exist.";
          } else if (data.running) {
            dot.style.background = "#4ade80";
            text.textContent = "Running";
            const upSince = data.startedAt ? new Date(data.startedAt).toLocaleString() : "";
            detail.textContent = upSince ? "Up since " + upSince : "Container is running.";
          } else {
            dot.style.background = "#f87171";
            text.textContent = "Stopped";
            detail.textContent = "Status: " + (data.status || "exited");
          }
        } catch {
          const dot = $("cf-status-dot");
          const text = $("cf-status-text");
          const detail = $("cf-status-detail");
          if (dot) dot.style.background = "#f59e0b";
          if (text) text.textContent = "Unknown";
          if (detail) detail.textContent = "Could not query Docker. Socket may not be mounted.";
        }
      }

      async function cfAction(action) {
        const sts = $("cf-action-status");
        sts.textContent = action.charAt(0).toUpperCase() + action.slice(1) + "ing…";
        sts.style.color = "#C9A04E";
        try {
          const data = await fetchJSON("/api/admin/cloudflare/" + action, { method: "POST" });
          sts.textContent = data.message || "Done.";
          sts.style.color = "#4ade80";
          // Refresh status after a short delay to let Docker settle
          setTimeout(loadCloudflareStatus, 2000);
          setTimeout(() => { if (sts.style.color === "rgb(74, 222, 128)") sts.textContent = ""; }, 5000);
        } catch (err) {
          sts.textContent = "Failed: " + err.message;
          sts.style.color = "#f87171";
          loadCloudflareStatus();
        }
      }

      async function saveCloudflareToken() {
        const token = $("cf-tunnel-token").value.trim();
        if (!token) {
          $("cf-token-status").textContent = "Please enter a tunnel token.";
          return;
        }
        try {
          await fetchJSON("/api/admin/cloudflare/token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token }),
          });
          $("cf-tunnel-token").value = "";
          $("cf-token-status").innerHTML = '<span style="color: var(--primary);">&#10003; Tunnel token saved successfully.</span>';
          setStatus("Cloudflare token saved", "ok");
        } catch (err) {
          $("cf-token-status").textContent = "Save failed: " + err.message;
          setStatus("Cloudflare token save failed", "err");
        }
      }

      /* ── Owner Passcode ─────────────────── */
      async function saveOwnerPasscode() {
        const sts = $("passcode-status");
        const tenantId = ($("passcode-tenant").value || "").trim();
        const passcode = ($("passcode-value").value || "").trim();
        if (!tenantId) { sts.textContent = "Tenant ID is required."; sts.style.color = "#f87171"; return; }
        if (!passcode || passcode.length < 4) { sts.textContent = "Passcode must be at least 4 characters."; sts.style.color = "#f87171"; return; }
        try {
          await fetchJSON("/api/owner/set-passcode", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ tenantId, passcode }),
          });
          sts.textContent = "Passcode set for " + escapeHtml(tenantId) + "!";
          sts.style.color = "#4ade80";
          $("passcode-value").value = "";
          setTimeout(() => { if (sts.textContent.includes("set for")) sts.textContent = ""; }, 5000);
        } catch (e) {
          sts.textContent = "Failed: " + e.message;
          sts.style.color = "#f87171";
        }
      }

      /* ── Capacity & Concurrency ─────────────────── */
      const CAP_SLIDERS = [
        { id: "cap-global-concurrency", valId: "cap-global-val", path: "global.concurrencyCap", fmt: v => Math.round(v).toString() },
        { id: "cap-tenant-concurrency", valId: "cap-tenant-concurrency-val", path: "tenant.concurrencyCap", fmt: v => Math.round(v).toString() },
        { id: "cap-tenant-rpm", valId: "cap-tenant-rpm-val", path: "tenant.rpmCap", fmt: v => Math.round(v).toString() },
        { id: "cap-whisper", valId: "cap-whisper-val", path: "services.whisperMaxConcurrent", fmt: v => Math.round(v).toString() },
        { id: "cap-kokoro", valId: "cap-kokoro-val", path: "services.kokoroMaxConcurrent", fmt: v => Math.round(v).toString() },
        { id: "cap-xtts", valId: "cap-xtts-val", path: "services.xttsMaxConcurrent", fmt: v => Math.round(v).toString() },
      ];

      function getNestedValue(obj, path) {
        return path.split(".").reduce((o, k) => o?.[k], obj);
      }

      function bindCapSliders() {
        CAP_SLIDERS.forEach(({ id, valId, fmt }) => {
          const el = $(id);
          if (!el) return;
          el.addEventListener("input", () => {
            const v = $(valId);
            if (v) v.textContent = fmt(el.value);
          });
        });
      }

      async function loadCapacity() {
        try {
          const data = await fetchJSON("/api/admin/capacity");
          CAP_SLIDERS.forEach(({ id, valId, path, fmt }) => {
            const el = $(id);
            const v = $(valId);
            const val = getNestedValue(data, path);
            if (el && val !== undefined) { el.value = val; }
            if (v && val !== undefined) { v.textContent = fmt(val); }
          });
          const ga = $("cap-global-active");
          const ta = $("cap-tenant-active");
          if (ga) ga.textContent = data.global?.activeCalls ?? "—";
          if (ta) ta.textContent = data.tenant?.activeCalls ?? "—";
        } catch (e) {
          console.error("loadCapacity:", e);
        }
      }

      async function saveCapacity() {
        const sts = $("cap-status");
        try {
          const body = {
            global: {
              concurrencyCap: parseInt($("cap-global-concurrency")?.value || "100"),
            },
            tenant: {
              concurrencyCap: parseInt($("cap-tenant-concurrency")?.value || "10"),
              rpmCap: parseInt($("cap-tenant-rpm")?.value || "60"),
            },
            services: {
              whisperMaxConcurrent: parseInt($("cap-whisper")?.value || "2"),
              kokoroMaxConcurrent: parseInt($("cap-kokoro")?.value || "2"),
              xttsMaxConcurrent: parseInt($("cap-xtts")?.value || "0"),
            },
          };
          const result = await fetchJSON("/api/admin/capacity", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          sts.textContent = "Saved! " + (result.changes || []).join(", ");
          sts.style.color = "#4ade80";
          setTimeout(() => { if (sts.textContent.startsWith("Saved")) sts.textContent = ""; }, 4000);
          loadCapacity(); // refresh live counts
        } catch (e) {
          sts.textContent = "Failed: " + e.message;
          sts.style.color = "#f87171";
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll(".tab").forEach((tab) => {
          tab.addEventListener("click", () => {
            const target = tab.dataset.tab;
            if (target) {
              document.querySelectorAll(".tab").forEach((t) => {
                t.classList.toggle("active", t.dataset.tab === target);
              });
              document.querySelectorAll(".tab-content").forEach((content) => {
                content.classList.toggle("active", content.dataset.tab === target);
              });
            }
            if (tab.id === "refresh-all") refreshAll();
          });
        });

        const tenantSelect = $("tenant-select");
        if (tenantSelect) {
          tenantSelect.addEventListener("change", () => {
            currentTenantId = tenantSelect.value;
            renderTenantMeta();
            refreshAll();
            const pt = $("passcode-tenant");
            if (pt) pt.value = currentTenantId;
          });
        }

        const tenantReload = $("tenant-reload");
        if (tenantReload) tenantReload.addEventListener("click", () => loadTenants());

        const tenantCreate = $("tenant-create");
        if (tenantCreate) tenantCreate.addEventListener("click", saveTenantFromForm);

        $("config-form").addEventListener("submit", saveConfig);
        $("provider").addEventListener("change", toggleProviderFields);
        $("refresh-config").addEventListener("click", () => loadConfig(true));
        $("prompt-form").addEventListener("submit", savePrompts);
        $("refresh-prompts").addEventListener("click", () => loadPrompts(true));

        const refreshHealthBtn = $("refresh-health");
        if (refreshHealthBtn) {
          refreshHealthBtn.addEventListener("click", () => {
            setStatus("Refreshing health…", "ok");
            loadHealth();
          });
        }

        const refreshAnalyticsBtn = $("refresh-analytics");
        if (refreshAnalyticsBtn) {
          refreshAnalyticsBtn.addEventListener("click", () => {
            setStatus("Refreshing analytics…", "ok");
            loadAnalytics();
          });
        }

        const refreshCallsBtn = $("refresh-calls");
        if (refreshCallsBtn) {
          refreshCallsBtn.addEventListener("click", () => {
            setStatus("Refreshing calls…", "ok");
            loadCalls();
          });
        }

        const refreshAuditBtn = $("refresh-audit");
        if (refreshAuditBtn) {
          refreshAuditBtn.addEventListener("click", () => {
            setStatus("Refreshing audit logs…", "ok");
            loadAudit();
          });
        }

        const refreshKeysBtn = $("refresh-keys");
        if (refreshKeysBtn) {
          refreshKeysBtn.addEventListener("click", () => {
            setStatus("Refreshing admin keys…", "ok");
            loadAdminKeys();
          });
        }

        // Cloudflare Tunnel
        const cfSave = $("cf-save-token");
        if (cfSave) cfSave.addEventListener("click", () => requireAuth(saveCloudflareToken));
        const cfStart = $("cf-start-btn");
        if (cfStart) cfStart.addEventListener("click", () => cfAction("start"));
        const cfStop = $("cf-stop-btn");
        if (cfStop) cfStop.addEventListener("click", () => cfAction("stop"));
        const cfRestart = $("cf-restart-btn");
        if (cfRestart) cfRestart.addEventListener("click", () => cfAction("restart"));
        const cfRefresh = $("cf-refresh-status");
        if (cfRefresh) cfRefresh.addEventListener("click", loadCloudflareStatus);

        const cfToggle = $("cf-toggle-visibility");
        if (cfToggle) {
          cfToggle.addEventListener("click", () => {
            const input = $("cf-tunnel-token");
            if (input.type === "password") {
              input.type = "text";
              cfToggle.textContent = "Hide";
            } else {
              input.type = "password";
              cfToggle.textContent = "Show";
            }
          });
        }

        // Owner passcode
        const passcodeSave = $("passcode-save");
        if (passcodeSave) passcodeSave.addEventListener("click", () => requireAuth(saveOwnerPasscode));
        // Auto-fill tenant ID from selector
        const passcTenant = $("passcode-tenant");
        if (passcTenant && !passcTenant.value && currentTenantId) passcTenant.value = currentTenantId;

        // Capacity controls
        bindCapSliders();
        const capSave = $("cap-save");
        if (capSave) capSave.addEventListener("click", () => saveCapacity());
        const capRefresh = $("cap-refresh");
        if (capRefresh) capRefresh.addEventListener("click", () => loadCapacity());

        const fpAdd = $("fp-add");
        if (fpAdd) {
          fpAdd.addEventListener("click", () => {
            const name = ($("fp-name")?.value || "").trim();
            const number = ($("fp-number")?.value || "").trim();
            const role = ($("fp-role")?.value || "").trim();
            const description = ($("fp-desc")?.value || "").trim();
            if (!name) return;
            forwardingProfilesCache.push({ id: "id_" + Date.now(), name, number, role, description });
            if ($("fp-name")) $("fp-name").value = "";
            if ($("fp-number")) $("fp-number").value = "";
            if ($("fp-role")) $("fp-role").value = "";
            if ($("fp-desc")) $("fp-desc").value = "";
            renderForwardingProfiles();
          });
        }
        const fpSave = $("fp-save");
        if (fpSave) fpSave.addEventListener("click", () => saveForwardingProfiles());

        const priceAdd = $("price-add");
        if (priceAdd) {
          priceAdd.addEventListener("click", () => {
            const type = ($("price-type")?.value || "service");
            const name = ($("price-name")?.value || "").trim();
            const price = ($("price-amount")?.value || "").trim();
            const desc = ($("price-desc")?.value || "").trim();
            if (!name) return;
            if (!pricingCache.items) pricingCache.items = [];
            pricingCache.items.push({ id: "id_" + Date.now(), type, name, price, description: desc || undefined });
            if ($("price-name")) $("price-name").value = "";
            if ($("price-amount")) $("price-amount").value = "";
            if ($("price-desc")) $("price-desc").value = "";
            renderPricing();
          });
        }
        const priceSave = $("price-save");
        if (priceSave) priceSave.addEventListener("click", () => savePricing());

        // Subscription / Billing — auto-save toggle (PATCH: only updates existing record, won't create)
        const showPortalToggle = $("sub-show-portal");
        if (showPortalToggle) showPortalToggle.addEventListener("change", async () => {
          try {
            const result = await fetchJSON("/api/admin/subscription", {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ showBillingPortal: showPortalToggle.checked }),
            });
            if (result.configured === false) {
              setStatus("Assign a plan first before toggling visibility", "err");
              showPortalToggle.checked = false;
              return;
            }
            setStatus(showPortalToggle.checked ? "Billing visible to owner" : "Billing hidden from owner", "ok");
          } catch (err) {
            setStatus("Toggle failed: " + err.message, "err");
          }
        });
        const subSave = $("sub-save");
        if (subSave) subSave.addEventListener("click", () => saveSubscription());
        const subRefresh = $("sub-refresh");
        if (subRefresh) subRefresh.addEventListener("click", () => loadSubscription());
        // Stripe admin extras (notes + toggle save when Stripe is active)
        const subSaveStripe = $("sub-save-stripe");
        if (subSaveStripe) subSaveStripe.addEventListener("click", async () => {
          const statusEl = $("sub-status-msg-stripe");
          try {
            await fetchJSON("/api/admin/subscription", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                showBillingPortal: $("sub-show-portal").checked,
                adminNotes: ($("sub-notes-stripe").value || "").trim() || null,
              }),
            });
            if (statusEl) statusEl.textContent = "Saved.";
            setStatus("Billing settings saved", "ok");
          } catch (err) {
            if (statusEl) statusEl.textContent = "Save failed: " + err.message;
          }
        });
        const subRefreshStripe = $("sub-refresh-stripe");
        if (subRefreshStripe) subRefreshStripe.addEventListener("click", () => loadSubscription());

        // Stripe
        const stripeCreatePlanBtn = $("stripe-create-plan");
        if (stripeCreatePlanBtn) stripeCreatePlanBtn.addEventListener("click", () => createStripePlan());
        const stripeAssignBtn = $("stripe-assign-save");
        if (stripeAssignBtn) stripeAssignBtn.addEventListener("click", () => assignStripePlan());
        const subRemoveBtn = $("sub-remove");
        if (subRemoveBtn) subRemoveBtn.addEventListener("click", () => removeSubscription());
        const stripeCheckoutBtn = $("stripe-send-checkout");
        if (stripeCheckoutBtn) stripeCheckoutBtn.addEventListener("click", () => stripeCheckout());
        const stripePortalBtn = $("stripe-open-portal");
        if (stripePortalBtn) stripePortalBtn.addEventListener("click", () => stripePortal());
        const stripeSyncBtn = $("stripe-sync");
        if (stripeSyncBtn) stripeSyncBtn.addEventListener("click", () => stripeSync());

        const createKeyBtn = $("create-admin-key");
        if (createKeyBtn) {
          createKeyBtn.addEventListener("click", () => {
            createAdminKey();
          });
        }

        const refreshDebugBtn = $("refresh-debug");
        if (refreshDebugBtn) {
          refreshDebugBtn.addEventListener("click", () => {
            setStatus("Refreshing diagnostics…", "ok");
            loadConfig(true);
            loadHealth();
          });
        }

        $("admin-pass-confirm").addEventListener("click", handleAdminConfirm);
        $("admin-pass-cancel").addEventListener("click", () => {
          hideAdminModal();
          setStatus("Admin action canceled", "err");
        });

        $("admin-pass-input").addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            handleAdminConfirm();
          }
        });

        $("openaiApiKey").addEventListener("focus", () => {
          if (!adminAuthorized) {
            requestAdminPasscode();
            $("openaiApiKey").blur();
          }
        });

        // TTS slider label
        if ($("ttsRate")) {
          $("ttsRate").addEventListener("input", updateTtsLabels);
          updateTtsLabels();
        }

        // TTS mode change handler
        const ttsModeEl = $("ttsMode");
        if (ttsModeEl) {
          ttsModeEl.addEventListener("change", updateVoiceCloningVisibility);
        }

        // Voice cloning validation triggers
        const defaultVoiceModeEl = $("defaultVoiceMode");
        if (defaultVoiceModeEl) {
          defaultVoiceModeEl.addEventListener("change", updateVoiceCloningVisibility);
        }
        const clonedVoiceUrlEl = $("clonedVoiceUrl");
        if (clonedVoiceUrlEl) {
          clonedVoiceUrlEl.addEventListener("input", updateVoiceCloningVisibility);
        }

        // Audio recording controls
        const recordBtn = $("record-btn");
        if (recordBtn) {
          recordBtn.addEventListener("click", toggleRecording);
        }
        const useRecordingBtn = $("use-recording-btn");
        if (useRecordingBtn) {
          useRecordingBtn.addEventListener("click", useRecording);
        }
        const discardRecordingBtn = $("discard-recording-btn");
        if (discardRecordingBtn) {
          discardRecordingBtn.addEventListener("click", discardRecording);
        }

        // Active call voice control
        const getCallVoiceBtn = $("get-call-voice");
        if (getCallVoiceBtn) {
          getCallVoiceBtn.addEventListener("click", getCallVoiceMode);
        }
        const setCallVoiceBtn = $("set-call-voice");
        if (setCallVoiceBtn) {
          setCallVoiceBtn.addEventListener("click", setCallVoiceMode);
        }

        // TTS form
        const ttsForm = $("tts-form");
        if (ttsForm) ttsForm.addEventListener("submit", saveTtsConfig);

        // Workflow automation
        const wfNewBtn = $("wf-new-btn");
        if (wfNewBtn) wfNewBtn.addEventListener("click", () => showWorkflowBuilder(null));
        const wfRefreshBtn = $("wf-refresh-btn");
        if (wfRefreshBtn) wfRefreshBtn.addEventListener("click", () => loadWorkflows());
        const wfAddStep = $("wf-add-step");
        if (wfAddStep) wfAddStep.addEventListener("click", addWorkflowStep);
        const wfSaveBtn = $("wf-save-btn");
        if (wfSaveBtn) wfSaveBtn.addEventListener("click", () => saveWorkflow());
        const wfTestBtn = $("wf-test-btn");
        if (wfTestBtn) wfTestBtn.addEventListener("click", () => testWorkflow());
        const wfCancelBtn = $("wf-cancel-btn");
        if (wfCancelBtn) wfCancelBtn.addEventListener("click", hideWorkflowBuilder);
        const wfRunsRefresh = $("wf-runs-refresh");
        if (wfRunsRefresh) wfRunsRefresh.addEventListener("click", () => loadWorkflowRuns());
        const wfLeadsRefresh = $("wf-leads-refresh");
        if (wfLeadsRefresh) wfLeadsRefresh.addEventListener("click", () => loadLeads());
        const wfTriggerType = $("wf-trigger-type");
        if (wfTriggerType) wfTriggerType.addEventListener("change", updateTriggerConfigUI);
        const wfOwnerEdit = $("wf-owner-edit");
        if (wfOwnerEdit) wfOwnerEdit.addEventListener("change", async () => {
          try {
            await fetchJSON("/api/admin/workflows/settings", {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ ownerCanEdit: wfOwnerEdit.checked }),
            });
            setStatus(wfOwnerEdit.checked ? "Owner workflow editing enabled" : "Owner workflow editing disabled", "ok");
          } catch (err) {
            setStatus("Failed: " + err.message, "err");
          }
        });

        const wfCustomBranding = $("wf-custom-branding");
        if (wfCustomBranding) wfCustomBranding.addEventListener("change", async () => {
          try {
            await fetchJSON("/api/admin/workflows/settings", {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ customBrandingEnabled: wfCustomBranding.checked }),
            });
            setStatus(wfCustomBranding.checked ? "Custom branding enabled for owner" : "Custom branding disabled for owner", "ok");
          } catch (err) {
            setStatus("Failed: " + err.message, "err");
          }
        });

        const startApp = () => {
          loadTenants().then(() => {
            refreshAll();
            setInterval(loadHealth, 15000);
            setInterval(loadAnalytics, 20000);
            setInterval(loadCalls, 20000);
            setInterval(loadAudit, 30000);
            setInterval(loadAdminKeys, 45000);
          });
        };

        if (adminAuthToken) {
          startApp();
        } else {
          requestAdminPasscode(startApp);
        }
      });
    </script>
    <script src="vl-select.js"></script>
  </body>
</html>
