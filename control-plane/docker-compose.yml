# VeraLux control plane â€” full stack (app + Postgres + Redis)
# Run: docker compose up -d
# Then open http://localhost:4000/admin or http://localhost:4000/owner

services:
  db:
    image: postgres:15-alpine
    restart: unless-stopped
    environment:
      POSTGRES_USER: veralux
      POSTGRES_PASSWORD: veralux
      POSTGRES_DB: veralux
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U veralux -d veralux"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  app:
    build: .
    restart: unless-stopped
    depends_on:
      db: { condition: service_healthy }
      redis: { condition: service_healthy }
    ports:
      - "4000:4000"
    environment:
      NODE_ENV: production
      PORT: 4000
      DATABASE_URL: postgres://veralux:veralux@db:5432/veralux
      REDIS_URL: redis://redis:6379
      ENABLE_RUNTIME_ADMIN: "true"
      SECRET_MANAGER: db
      # Override in .env or set at runtime:
      ADMIN_API_KEY: ${ADMIN_API_KEY:?Set ADMIN_API_KEY in .env or environment}
      SECRET_ENCRYPTION_KEY: ${SECRET_ENCRYPTION_KEY:-change-me-32-bytes-required!!!!!!!!}
      ADMIN_ALLOWED_ORIGINS: ${ADMIN_ALLOWED_ORIGINS:-http://localhost:4000}
    # Optional: mount .env for local overrides (do not commit secrets)
    # env_file: .env

  # Cloudflare Tunnel - exposes the app to the internet
  # Set CLOUDFLARE_TUNNEL_TOKEN in .env or environment
  tunnel:
    image: cloudflare/cloudflared:latest
    restart: unless-stopped
    depends_on:
      - app
    command: tunnel run
    environment:
      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN:-}

volumes:
  pgdata:
