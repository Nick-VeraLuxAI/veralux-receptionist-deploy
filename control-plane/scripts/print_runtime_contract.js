const fs = require("node:fs");
const path = require("node:path");

const { createRuntimePublisher } = require("../dist/runtime/runtimePublisher");
const {
  parseRuntimeTenantConfig,
  E164_REGEX,
} = require("../dist/runtime/runtimeContract");

const DID_PLACEHOLDER = "{{DID_E164}}";
const TENANT_PLACEHOLDER = "{{TENANT_ID}}";

function buildExampleConfig() {
  return parseRuntimeTenantConfig({
    contractVersion: "v1",
    tenantId: TENANT_PLACEHOLDER,
    dids: ["+15551234567"],
    webhookSecretRef: "secret://runtime/webhook",
    webhookSecret: "REDACTED",
    caps: {
      maxConcurrentCallsTenant: 10,
      maxCallsPerMinuteTenant: 60,
      maxConcurrentCallsGlobal: 200,
    },
    stt: {
      mode: "whisper_http",
      whisperUrl: "https://stt.example.com/transcribe",
      chunkMs: 500,
      language: "en",
    },
    tts: {
      mode: "kokoro_http",
      kokoroUrl: "https://tts.example.com/tts",
      voice: "default",
      format: "wav",
      sampleRate: 24000,
    },
    audio: {
      publicBaseUrl: "https://api.example.com/audio",
      storageDir: "/var/lib/veralux/audio",
      runtimeManaged: true,
    },
  });
}

async function captureRedisKeys(exampleConfig) {
  const captured = { setKeys: [], delKeys: [] };
  const didSample = "+15551234567";
  const redis = {
    async get() {
      return null;
    },
    async set(key) {
      captured.setKeys.push(key);
      return "OK";
    },
    async del(key) {
      captured.delKeys.push(key);
      return 1;
    },
  };

  const publisher = createRuntimePublisher(redis);
  await publisher.mapDidToTenant(didSample, TENANT_PLACEHOLDER);
  await publisher.publishTenantConfig(TENANT_PLACEHOLDER, exampleConfig);
  await publisher.unmapDid(didSample);

  const didKey = captured.setKeys.find((key) => key.includes(didSample));
  const cfgKey = captured.setKeys.find(
    (key) => key.includes(TENANT_PLACEHOLDER) && !key.includes(DID_PLACEHOLDER)
  );

  if (!didKey || !cfgKey) {
    throw new Error("Unable to derive Redis key formats from runtimePublisher.");
  }

  const didKeyFormat = didKey.replace(didSample, DID_PLACEHOLDER);
  return {
    didKey: didKeyFormat,
    cfgKey,
    didPrefix: didKey.replace(didSample, ""),
    cfgPrefix: cfgKey.replace(TENANT_PLACEHOLDER, ""),
  };
}

function buildReport({ didKey, cfgKey, didPrefix, cfgPrefix }, exampleConfig) {
  const lines = [];

  lines.push("# Runtime Integration Report");
  lines.push("");
  lines.push("Generated by `scripts/print_runtime_contract.js`.");
  lines.push("");
  lines.push("Source modules:");
  lines.push("- src/runtime/runtimePublisher.ts");
  lines.push("- src/runtime/runtimeContract.ts");
  lines.push("- src/server.ts");
  lines.push("");
  lines.push("Redis keys:");
  lines.push(`- DID mapping key format: \`${didKey}\``);
  lines.push(`- Tenant config key format: \`${cfgKey}\``);
  lines.push(
    `- Prefixes: \`${didPrefix}\`, \`${cfgPrefix}\` (hardcoded; no env-driven prefixes)`
  );
  lines.push("");
  lines.push("RuntimeTenantConfig (representative JSON, secrets redacted):");
  lines.push("```json");
  lines.push(JSON.stringify(exampleConfig, null, 2));
  lines.push("```");
  lines.push("Notes:");
  lines.push("- `contractVersion` is currently `v1`.");
  lines.push(
    "- `webhookSecretRef` or `webhookSecret` is required by schema; redact `webhookSecret` in docs/logs."
  );
  lines.push("");
  lines.push("Env vars:");
  lines.push("- `REDIS_URL`: Redis connection URL used by runtime publisher.");
  lines.push(
    "- `ENABLE_RUNTIME_ADMIN`: Enables runtime admin endpoints; if true and `REDIS_URL` missing, server exits on startup."
  );
  lines.push(
    "- `ALLOW_RUNTIME_SECRET_READ`: Allows `?includeSecrets=1` to return `webhookSecret` from admin endpoints."
  );
  lines.push("");
  lines.push("Normalization:");
  lines.push(
    `- \`didE164\` is normalized (trim + internal whitespace removal) in admin endpoints before map/unmap/lookup and validated against E.164 regex \`${E164_REGEX}\`.`
  );
  lines.push(
    "- `dids` in `RuntimeTenantConfig` are validated with the same E.164 regex."
  );
  lines.push(
    "- `tenantId` from runtime admin routes is trimmed; runtimePublisher does not normalize tenant IDs."
  );
  lines.push(
    "- All DIDs are normalized to E.164 on publish; runtime assumes normalized lookup."
  );
  lines.push("");
  lines.push("Failure behavior:");
  lines.push(
    "- Redis down/unreachable -> publisher operations throw; admin endpoints return 500 with:"
  );
  lines.push(
    '- POST /api/admin/runtime/tenants/:tenantId/config: `{ error: "runtime_publish_failed" }`'
  );
  lines.push(
    '- GET /api/admin/runtime/tenants/:tenantId/config: `{ error: "runtime_config_read_failed" }`'
  );
  lines.push(
    '- POST /api/admin/runtime/dids/map: `{ error: "runtime_map_failed" }`'
  );
  lines.push(
    '- POST /api/admin/runtime/dids/unmap: `{ error: "runtime_unmap_failed" }`'
  );
  lines.push(
    '- GET /api/admin/runtime/dids/:didE164: `{ error: "runtime_lookup_failed" }`'
  );
  lines.push(
    "- GET /api/admin/runtime/health returns 503 with `{ ok: false, error }` when ping/get fails; 500 with `{ error: \"runtime_health_failed\" }` on unexpected exceptions."
  );
  lines.push(
    '- If `ENABLE_RUNTIME_ADMIN` is false, runtime admin endpoints return 503 `{ error: "runtime_admin_disabled" }`.'
  );

  return `${lines.join("\n")}\n`;
}

async function main() {
  const exampleConfig = buildExampleConfig();
  const keyInfo = await captureRedisKeys(exampleConfig);
  const report = buildReport(keyInfo, exampleConfig);

  const outputPath = path.join(
    process.cwd(),
    "docs",
    "runtime_integration_report.md"
  );
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, report, "utf8");

  console.log(report);
  console.log(`Wrote ${outputPath}`);
}

main().catch((err) => {
  console.error("Failed to generate runtime integration report:", err);
  process.exit(1);
});
